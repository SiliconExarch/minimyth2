From 3d03d24c010e0bb160f04a8064b67188a014c25f Mon Sep 17 00:00:00 2001
From: Detlev Casanova <detlev.casanova@collabora.com>
Date: Thu, 3 Oct 2024 17:16:09 -0400
Subject: [PATCH 94/94] wip: Fix HDMI Audio

---
 .../bridge/synopsys/dw-hdmi-qp-i2s-audio.c    |  13 +-
 drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c  | 263 +++++-------------
 drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c   |   4 +-
 include/drm/bridge/dw_hdmi.h                  |  27 +-
 include/drm/bridge/dw_hdmi_qp.h               |  32 +++
 5 files changed, 114 insertions(+), 225 deletions(-)

diff --git a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-i2s-audio.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-i2s-audio.c
index e07c2b423..75acb5cc7 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-i2s-audio.c
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-i2s-audio.c
@@ -9,7 +9,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/module.h>
 
-#include <drm/bridge/dw_hdmi.h>
+#include <drm/bridge/dw_hdmi_qp.h>
 #include <drm/drm_crtc.h>
 
 #include <sound/hdmi-codec.h>
@@ -59,7 +59,7 @@ static int dw_hdmi_qp_i2s_hw_params(struct device *dev, void *data,
 		ref2stream = true;
 
 	dw_hdmi_qp_set_audio_interface(hdmi, fmt, hparms);
-	dw_hdmi_qp_set_sample_rate(hdmi, hparms->sample_rate);
+	//dw_hdmi_qp_set_sample_rate(hdmi, hparms->sample_rate);
 	dw_hdmi_qp_set_channel_status(hdmi, hparms->iec.status, ref2stream);
 	dw_hdmi_qp_set_channel_count(hdmi, hparms->channels);
 	dw_hdmi_qp_set_channel_allocation(hdmi, hparms->cea.channel_allocation);
@@ -120,10 +120,7 @@ static int dw_hdmi_qp_i2s_hook_plugged_cb(struct device *dev, void *data,
 					  hdmi_codec_plugged_cb fn,
 					  struct device *codec_dev)
 {
-	struct dw_hdmi_qp_i2s_audio_data *audio = data;
-	struct dw_hdmi_qp *hdmi = audio->hdmi;
-
-	return dw_hdmi_qp_set_plugged_cb(hdmi, fn, codec_dev);
+	return 0;
 }
 
 static struct hdmi_codec_ops dw_hdmi_qp_i2s_ops = {
@@ -164,13 +161,11 @@ static int snd_dw_hdmi_qp_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int snd_dw_hdmi_qp_remove(struct platform_device *pdev)
+static void snd_dw_hdmi_qp_remove(struct platform_device *pdev)
 {
 	struct platform_device *platform = dev_get_drvdata(&pdev->dev);
 
 	platform_device_unregister(platform);
-
-	return 0;
 }
 
 static struct platform_driver snd_dw_hdmi_qp_driver = {
diff --git a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c
index fcc785e2f..7f886706a 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c
@@ -53,18 +53,6 @@ struct dw_hdmi_qp_cec {
 };
 #endif
 
-/*
- * Recommended N and Expected CTS Values in FRL Mode in chapter 9.2.2
- * of HDMI Specification 2.1.
- */
-static const struct dw_hdmi_audio_frl_n common_frl_n_table[] = {
-	{ .r_bit = 3,  .n_32k = 4224, .n_44k1 = 5292, .n_48k = 5760, },
-	{ .r_bit = 6,  .n_32k = 4032, .n_44k1 = 5292, .n_48k = 6048, },
-	{ .r_bit = 8,  .n_32k = 4032, .n_44k1 = 3969, .n_48k = 6048, },
-	{ .r_bit = 10, .n_32k = 3456, .n_44k1 = 3969, .n_48k = 5184, },
-	{ .r_bit = 12, .n_32k = 3072, .n_44k1 = 3969, .n_48k = 4752, },
-};
-
 /*
  * Unless otherwise noted, entries in this table are 100% optimization.
  * Values can be obtained from hdmi_compute_n() but that function is
@@ -134,6 +122,7 @@ struct dw_hdmi_qp_i2c {
 
 struct dw_hdmi_qp {
 	struct drm_bridge bridge;
+	struct platform_device *audio;
 
 	struct device *dev;
 	struct dw_hdmi_qp_i2c *i2c;
@@ -150,6 +139,11 @@ struct dw_hdmi_qp {
 	struct drm_connector *curr_conn;
 	unsigned long long pix_clock;
 
+	spinlock_t audio_lock;
+	unsigned int sample_non_pcm;
+	unsigned int sample_width;
+	unsigned int channels;
+
 	struct mutex audio_mutex;
 	unsigned int sample_rate;
 	unsigned int audio_cts;
@@ -161,84 +155,45 @@ struct dw_hdmi_qp {
 	struct regmap *regm;
 };
 
-int dw_hdmi_qp_set_plugged_cb(struct dw_hdmi_qp *hdmi, hdmi_codec_plugged_cb fn,
-			      struct device *codec_dev)
+static void dw_hdmi_qp_write(struct dw_hdmi_qp *hdmi, unsigned int val,
+			     int offset)
 {
-	bool plugged;
+	regmap_write(hdmi->regm, offset, val);
+}
 
-	mutex_lock(&hdmi->mutex);
-	hdmi->plugged_cb = fn;
-	hdmi->codec_dev = codec_dev;
-	plugged = hdmi->last_connector_result == connector_status_connected;
-	handle_plugged_change(hdmi, plugged);
-	mutex_unlock(&hdmi->mutex);
+static unsigned int dw_hdmi_qp_read(struct dw_hdmi_qp *hdmi, int offset)
+{
+	unsigned int val = 0;
 
-	return 0;
+	regmap_read(hdmi->regm, offset, &val);
+
+	return val;
+}
+
+static void dw_hdmi_qp_mod(struct dw_hdmi_qp *hdmi, unsigned int data,
+			   unsigned int mask, unsigned int reg)
+{
+	regmap_update_bits(hdmi->regm, reg, mask, data);
 }
-EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_plugged_cb);
 
 static void hdmi_set_cts_n(struct dw_hdmi_qp *hdmi, unsigned int cts,
 			   unsigned int n)
 {
 	/* Set N */
-	hdmi_modb(hdmi, n, AUDPKT_ACR_N_VALUE, AUDPKT_ACR_CONTROL0);
+	dw_hdmi_qp_mod(hdmi, n, AUDPKT_ACR_N_VALUE, AUDPKT_ACR_CONTROL0);
 
 	/* Set CTS */
 	if (cts)
-		hdmi_modb(hdmi, AUDPKT_ACR_CTS_OVR_EN, AUDPKT_ACR_CTS_OVR_EN_MSK,
+		dw_hdmi_qp_mod(hdmi, AUDPKT_ACR_CTS_OVR_EN, AUDPKT_ACR_CTS_OVR_EN_MSK,
 			  AUDPKT_ACR_CONTROL1);
 	else
-		hdmi_modb(hdmi, 0, AUDPKT_ACR_CTS_OVR_EN_MSK,
+		dw_hdmi_qp_mod(hdmi, 0, AUDPKT_ACR_CTS_OVR_EN_MSK,
 			  AUDPKT_ACR_CONTROL1);
 
-	hdmi_modb(hdmi, AUDPKT_ACR_CTS_OVR_VAL(cts), AUDPKT_ACR_CTS_OVR_VAL_MSK,
+	dw_hdmi_qp_mod(hdmi, AUDPKT_ACR_CTS_OVR_VAL(cts), AUDPKT_ACR_CTS_OVR_VAL_MSK,
 		  AUDPKT_ACR_CONTROL1);
 }
 
-static int hdmi_match_frl_n_table(struct dw_hdmi_qp *hdmi,
-				  unsigned long r_bit,
-				  unsigned long freq)
-{
-	const struct dw_hdmi_audio_frl_n *frl_n = NULL;
-	int i = 0, n = 0;
-
-	for (i = 0; ARRAY_SIZE(common_frl_n_table); i++) {
-		if (r_bit == common_frl_n_table[i].r_bit) {
-			frl_n = &common_frl_n_table[i];
-			break;
-		}
-	}
-
-	if (!frl_n)
-		goto err;
-
-	switch (freq) {
-	case 32000:
-	case 64000:
-	case 128000:
-		n = (freq / 32000) * frl_n->n_32k;
-		break;
-	case 44100:
-	case 88200:
-	case 176400:
-		n = (freq / 44100) * frl_n->n_44k1;
-		break;
-	case 48000:
-	case 96000:
-	case 192000:
-		n = (freq / 48000) * frl_n->n_48k;
-		break;
-	default:
-		goto err;
-	}
-
-	return n;
-err:
-	dev_err(hdmi->dev, "FRL; unexpected Rbit: %lu Gbps\n", r_bit);
-
-	return 0;
-}
-
 static int hdmi_match_tmds_n_table(struct dw_hdmi_qp *hdmi,
 				   unsigned long pixel_clk,
 				   unsigned long freq)
@@ -328,17 +283,7 @@ static unsigned int hdmi_compute_n(struct dw_hdmi_qp *hdmi,
 static unsigned int hdmi_find_n(struct dw_hdmi_qp *hdmi, unsigned long pixel_clk,
 				unsigned long sample_rate)
 {
-	struct dw_hdmi_link_config *link_cfg = NULL;
-	void *data = hdmi->plat_data->phy_data;
-	int n;
-
-	if (hdmi->plat_data->get_link_cfg) {
-		link_cfg = hdmi->plat_data->get_link_cfg(data);
-		if (link_cfg && link_cfg->frl_mode)
-			return hdmi_match_frl_n_table(hdmi, link_cfg->rate_per_lane, sample_rate);
-	}
-
-	n = hdmi_match_tmds_n_table(hdmi, pixel_clk, sample_rate);
+	int n = hdmi_match_tmds_n_table(hdmi, pixel_clk, sample_rate);
 	if (n > 0)
 		return n;
 
@@ -355,24 +300,22 @@ void dw_hdmi_qp_set_audio_interface(struct dw_hdmi_qp *hdmi,
 	u32 conf0 = 0;
 
 	mutex_lock(&hdmi->audio_mutex);
-	if (!hdmi->dclk_en) {
-		mutex_unlock(&hdmi->audio_mutex);
-		return;
-	}
+	// TODO: VOP's DCLK_VP[0-3] clocks must be activated before this can be done.
+	//       Check how to make sure they are activated.
 
 	/* Reset the audio data path of the AVP */
-	hdmi_writel(hdmi, AVP_DATAPATH_PACKET_AUDIO_SWINIT_P, GLOBAL_SWRESET_REQUEST);
+	dw_hdmi_qp_write(hdmi, AVP_DATAPATH_PACKET_AUDIO_SWINIT_P, GLOBAL_SWRESET_REQUEST);
 
 	/* Disable AUDS, ACR, AUDI */
-	hdmi_modb(hdmi, 0,
+	dw_hdmi_qp_mod(hdmi, 0,
 		  PKTSCHED_ACR_TX_EN | PKTSCHED_AUDS_TX_EN | PKTSCHED_AUDI_TX_EN,
 		  PKTSCHED_PKT_EN);
 
 	/* Clear the audio FIFO */
-	hdmi_writel(hdmi, AUDIO_FIFO_CLR_P, AUDIO_INTERFACE_CONTROL0);
+	dw_hdmi_qp_write(hdmi, AUDIO_FIFO_CLR_P, AUDIO_INTERFACE_CONTROL0);
 
 	/* Select I2S interface as the audio source */
-	hdmi_modb(hdmi, AUD_IF_I2S, AUD_IF_SEL_MSK, AUDIO_INTERFACE_CONFIG0);
+	dw_hdmi_qp_mod(hdmi, AUD_IF_I2S, AUD_IF_SEL_MSK, AUDIO_INTERFACE_CONFIG0);
 
 	/* Enable the active i2s lanes */
 	switch (hparms->channels) {
@@ -390,7 +333,7 @@ void dw_hdmi_qp_set_audio_interface(struct dw_hdmi_qp *hdmi,
 		break;
 	}
 
-	hdmi_modb(hdmi, conf0, I2S_LINES_EN_MSK, AUDIO_INTERFACE_CONFIG0);
+	dw_hdmi_qp_mod(hdmi, conf0, I2S_LINES_EN_MSK, AUDIO_INTERFACE_CONFIG0);
 
 	/*
 	 * Enable bpcuv generated internally for L-PCM, or received
@@ -406,11 +349,11 @@ void dw_hdmi_qp_set_audio_interface(struct dw_hdmi_qp *hdmi,
 		break;
 	}
 
-	hdmi_modb(hdmi, conf0, I2S_BPCUV_RCV_MSK | AUD_FORMAT_MSK,
+	dw_hdmi_qp_mod(hdmi, conf0, I2S_BPCUV_RCV_MSK | AUD_FORMAT_MSK,
 		  AUDIO_INTERFACE_CONFIG0);
 
 	/* Enable audio FIFO auto clear when overflow */
-	hdmi_modb(hdmi, AUD_FIFO_INIT_ON_OVF_EN, AUD_FIFO_INIT_ON_OVF_MSK,
+	dw_hdmi_qp_mod(hdmi, AUD_FIFO_INIT_ON_OVF_EN, AUD_FIFO_INIT_ON_OVF_MSK,
 		  AUDIO_INTERFACE_CONFIG0);
 
 	mutex_unlock(&hdmi->audio_mutex);
@@ -429,10 +372,9 @@ void dw_hdmi_qp_set_channel_status(struct dw_hdmi_qp *hdmi,
 				   u8 *channel_status, bool ref2stream)
 {
 	mutex_lock(&hdmi->audio_mutex);
-	if (!hdmi->dclk_en) {
-		mutex_unlock(&hdmi->audio_mutex);
-		return;
-	}
+
+	// TODO: VOP's DCLK_VP[0-3] clocks must be activated before this can be done.
+	//       Check how to make sure they are activated.
 
 	/*
 	 * AUDPKT_CHSTATUS_OVR0: { RSV, RSV, CS1, CS0 }
@@ -456,23 +398,23 @@ void dw_hdmi_qp_set_channel_status(struct dw_hdmi_qp *hdmi,
 	if (ref2stream)
 		channel_status[0] |= IEC958_AES0_NONAUDIO;
 
-	if ((hdmi_readl(hdmi, AUDIO_INTERFACE_CONFIG0) & GENMASK(25, 24)) == AUD_HBR) {
+	if ((dw_hdmi_qp_read(hdmi, AUDIO_INTERFACE_CONFIG0) & GENMASK(25, 24)) == AUD_HBR) {
 		/* fixup cs for HBR */
 		channel_status[3] = (channel_status[3] & 0xf0) | IEC958_AES3_CON_FS_768000;
 		channel_status[4] = (channel_status[4] & 0x0f) | IEC958_AES4_CON_ORIGFS_NOTID;
 	}
 
-	hdmi_writel(hdmi, channel_status[0] | (channel_status[1] << 8),
+	dw_hdmi_qp_write(hdmi, channel_status[0] | (channel_status[1] << 8),
 		    AUDPKT_CHSTATUS_OVR0);
 
 	regmap_bulk_write(hdmi->regm, AUDPKT_CHSTATUS_OVR1, &channel_status[3], 1);
 
 	if (ref2stream)
-		hdmi_modb(hdmi, 0,
+		dw_hdmi_qp_mod(hdmi, 0,
 			  AUDPKT_PBIT_FORCE_EN_MASK | AUDPKT_CHSTATUS_OVR_EN_MASK,
 			  AUDPKT_CONTROL0);
 	else
-		hdmi_modb(hdmi, AUDPKT_PBIT_FORCE_EN | AUDPKT_CHSTATUS_OVR_EN,
+		dw_hdmi_qp_mod(hdmi, AUDPKT_PBIT_FORCE_EN | AUDPKT_CHSTATUS_OVR_EN,
 			  AUDPKT_PBIT_FORCE_EN_MASK | AUDPKT_CHSTATUS_OVR_EN_MASK,
 			  AUDPKT_CONTROL0);
 
@@ -495,31 +437,22 @@ static void hdmi_set_clk_regenerator(struct dw_hdmi_qp *hdmi,
 static void hdmi_init_clk_regenerator(struct dw_hdmi_qp *hdmi)
 {
 	mutex_lock(&hdmi->audio_mutex);
-	if (hdmi->dclk_en)
-		hdmi_set_clk_regenerator(hdmi, 74250000, hdmi->sample_rate);
-	mutex_unlock(&hdmi->audio_mutex);
-}
-
-static void hdmi_clk_regenerator_update_pixel_clock(struct dw_hdmi_qp *hdmi)
-{
-	mutex_lock(&hdmi->audio_mutex);
-	if (hdmi->dclk_en)
-		hdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,
-					 hdmi->sample_rate);
+	// FIXME: Where does the 74250000 value come from ?
+	hdmi_set_clk_regenerator(hdmi, 74250000, hdmi->sample_rate);
 	mutex_unlock(&hdmi->audio_mutex);
 }
 
+/*
 void dw_hdmi_qp_set_sample_rate(struct dw_hdmi_qp *hdmi, unsigned int rate)
 {
 	mutex_lock(&hdmi->audio_mutex);
-	if (hdmi->dclk_en) {
-		hdmi->sample_rate = rate;
-		hdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,
-					 hdmi->sample_rate);
-	}
+	hdmi->sample_rate = rate;
+	hdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,
+				 hdmi->sample_rate);
 	mutex_unlock(&hdmi->audio_mutex);
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_sample_rate);
+*/
 
 void dw_hdmi_qp_set_channel_count(struct dw_hdmi_qp *hdmi, unsigned int cnt)
 {
@@ -553,7 +486,7 @@ static int dw_hdmi_qp_init_audio_infoframe(struct dw_hdmi_qp *hdmi)
 	}
 
 	regmap_bulk_write(hdmi->regm, PKT_AUDI_CONTENTS1, &infoframe_buf[3], 2);
-	hdmi_modb(hdmi,
+	dw_hdmi_qp_mod(hdmi,
 		  PKTSCHED_ACR_TX_EN | PKTSCHED_AUDI_TX_EN,
 		  PKTSCHED_ACR_TX_EN | PKTSCHED_AUDI_TX_EN,
 		  PKTSCHED_PKT_EN);
@@ -576,10 +509,8 @@ void dw_hdmi_qp_set_audio_infoframe(struct dw_hdmi_qp *hdmi,
 	}
 
 	mutex_lock(&hdmi->audio_mutex);
-	if (!hdmi->dclk_en) {
-		mutex_unlock(&hdmi->audio_mutex);
-		return;
-	}
+	// TODO: VOP's DCLK_VP[0-3] clocks must be activated before this can be done.
+	//       Check how to make sure they are activated.
 
 	/*
 	 * AUDI_CONTENTS0: { RSV, HB2, HB1, RSV }
@@ -601,13 +532,13 @@ void dw_hdmi_qp_set_audio_infoframe(struct dw_hdmi_qp *hdmi,
 	regmap_bulk_write(hdmi->regm, PKT_AUDI_CONTENTS1, &infoframe_buf[3], 2);
 
 	/* Enable ACR, AUDI, AMD */
-	hdmi_modb(hdmi,
+	dw_hdmi_qp_mod(hdmi,
 		  PKTSCHED_ACR_TX_EN | PKTSCHED_AUDI_TX_EN | PKTSCHED_AMD_TX_EN,
 		  PKTSCHED_ACR_TX_EN | PKTSCHED_AUDI_TX_EN | PKTSCHED_AMD_TX_EN,
 		  PKTSCHED_PKT_EN);
 
 	/* Enable AUDS */
-	hdmi_modb(hdmi, PKTSCHED_AUDS_TX_EN, PKTSCHED_AUDS_TX_EN, PKTSCHED_PKT_EN);
+	dw_hdmi_qp_mod(hdmi, PKTSCHED_AUDS_TX_EN, PKTSCHED_AUDS_TX_EN, PKTSCHED_PKT_EN);
 	mutex_unlock(&hdmi->audio_mutex);
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_audio_infoframe);
@@ -615,10 +546,10 @@ EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_audio_infoframe);
 static void hdmi_enable_audio_clk(struct dw_hdmi_qp *hdmi, bool enable)
 {
 	if (enable)
-		hdmi_modb(hdmi, 0,
+		dw_hdmi_qp_mod(hdmi, 0,
 			  AVP_DATAPATH_PACKET_AUDIO_SWDISABLE, GLOBAL_SWDISABLE);
 	else
-		hdmi_modb(hdmi, AVP_DATAPATH_PACKET_AUDIO_SWDISABLE,
+		dw_hdmi_qp_mod(hdmi, AVP_DATAPATH_PACKET_AUDIO_SWDISABLE,
 			  AVP_DATAPATH_PACKET_AUDIO_SWDISABLE, GLOBAL_SWDISABLE);
 }
 
@@ -637,9 +568,9 @@ static void dw_hdmi_i2s_audio_disable(struct dw_hdmi_qp *hdmi)
 	 * This also fix POP sound on some SINK devices which wakeup
 	 * from suspend to active.
 	 */
-	hdmi_modb(hdmi, I2S_BPCUV_RCV_DIS, I2S_BPCUV_RCV_MSK,
+	dw_hdmi_qp_mod(hdmi, I2S_BPCUV_RCV_DIS, I2S_BPCUV_RCV_MSK,
 		  AUDIO_INTERFACE_CONFIG0);
-	hdmi_modb(hdmi, AUDPKT_PBIT_FORCE_EN | AUDPKT_CHSTATUS_OVR_EN,
+	dw_hdmi_qp_mod(hdmi, AUDPKT_PBIT_FORCE_EN | AUDPKT_CHSTATUS_OVR_EN,
 		  AUDPKT_PBIT_FORCE_EN_MASK | AUDPKT_CHSTATUS_OVR_EN_MASK,
 		  AUDPKT_CONTROL0);
 }
@@ -647,11 +578,11 @@ static void dw_hdmi_i2s_audio_disable(struct dw_hdmi_qp *hdmi)
 void dw_hdmi_qp_audio_enable(struct dw_hdmi_qp *hdmi)
 {
 	mutex_lock(&hdmi->audio_mutex);
-	if (hdmi->dclk_en) {
-		hdmi->audio_enable = true;
-		if (hdmi->enable_audio)
-			hdmi->enable_audio(hdmi);
-	}
+
+	hdmi->audio_enable = true;
+	if (hdmi->enable_audio)
+		hdmi->enable_audio(hdmi);
+
 	mutex_unlock(&hdmi->audio_mutex);
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_qp_audio_enable);
@@ -659,11 +590,11 @@ EXPORT_SYMBOL_GPL(dw_hdmi_qp_audio_enable);
 void dw_hdmi_qp_audio_disable(struct dw_hdmi_qp *hdmi)
 {
 	mutex_lock(&hdmi->audio_mutex);
-	if (hdmi->dclk_en) {
-		hdmi->audio_enable = false;
-		if (hdmi->disable_audio)
-			hdmi->disable_audio(hdmi);
-	}
+
+	hdmi->audio_enable = false;
+	if (hdmi->disable_audio)
+		hdmi->disable_audio(hdmi);
+
 	mutex_unlock(&hdmi->audio_mutex);
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_qp_audio_disable);
@@ -719,27 +650,6 @@ void dw_hdmi_qp_set_high_tmds_clock_ratio(struct dw_hdmi_qp *hdmi,
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_high_tmds_clock_ratio);
 
-static void dw_hdmi_qp_write(struct dw_hdmi_qp *hdmi, unsigned int val,
-			     int offset)
-{
-	regmap_write(hdmi->regm, offset, val);
-}
-
-static unsigned int dw_hdmi_qp_read(struct dw_hdmi_qp *hdmi, int offset)
-{
-	unsigned int val = 0;
-
-	regmap_read(hdmi->regm, offset, &val);
-
-	return val;
-}
-
-static void dw_hdmi_qp_mod(struct dw_hdmi_qp *hdmi, unsigned int data,
-			   unsigned int mask, unsigned int reg)
-{
-	regmap_update_bits(hdmi->regm, reg, mask, data);
-}
-
 static int dw_hdmi_qp_i2c_read(struct dw_hdmi_qp *hdmi,
 			       unsigned char *buf, unsigned int length)
 {
@@ -1281,7 +1191,7 @@ static void dw_hdmi_qp_setup(struct dw_hdmi_qp *hdmi,
 	}
 
 	/* HDMI Initialization Step E - Configure audio */
-	hdmi_clk_regenerator_update_pixel_clock(hdmi);
+	((struct dw_hdmi_qp_i2s_audio_data*)hdmi->audio->dev.platform_data)->eld = connector->eld;
 	hdmi_enable_audio_clk(hdmi, hdmi->audio_enable);
 
 	dev_dbg(hdmi->dev, "%s HDMI mode\n", __func__);
@@ -1351,39 +1261,15 @@ static void dw_hdmi_qp_bridge_atomic_enable(struct drm_bridge *bridge,
 	dw_hdmi_qp_setup(hdmi, connector);
 
 	drm_atomic_helper_connector_hdmi_update_infoframes(connector, state);
-	
-	if (!hdmi->dclk_en) {
-		mutex_lock(&hdmi->audio_mutex);
-		if (hdmi->plat_data->dclk_set)
-			hdmi->plat_data->dclk_set(data, true);
-		hdmi->dclk_en = true;
-		mutex_unlock(&hdmi->audio_mutex);
-	}
+
 	dw_hdmi_qp_init_audio_infoframe(hdmi);
 	dw_hdmi_qp_audio_enable(hdmi);
-	hdmi_clk_regenerator_update_pixel_clock(hdmi);
-
-	//extcon_set_state_sync(hdmi->extcon, EXTCON_DISP_HDMI, true);
-	//handle_plugged_change(hdmi, true);
 }
 
 static void dw_hdmi_qp_bridge_atomic_disable(struct drm_bridge *bridge,
 					     struct drm_bridge_state *old_state)
 {
 	struct dw_hdmi_qp *hdmi = bridge->driver_private;
-	void *data = hdmi->plat_data->phy_data;
-
-	//extcon_set_state_sync(hdmi->extcon, EXTCON_DISP_HDMI, false);
-	//handle_plugged_change(hdmi, false);
-	mutex_lock(&hdmi->mutex);
-
-	if (hdmi->dclk_en) {
-		mutex_lock(&hdmi->audio_mutex);
-		if (hdmi->plat_data->dclk_set)
-			hdmi->plat_data->dclk_set(data, false);
-		hdmi->dclk_en = false;
-		mutex_unlock(&hdmi->audio_mutex);
-	};
 
 	hdmi->curr_conn = NULL;
 	hdmi->phy.ops->disable(hdmi, hdmi->phy.data);
@@ -1616,10 +1502,9 @@ struct dw_hdmi_qp *dw_hdmi_qp_bind(struct platform_device *pdev,
 		hdmi->bridge.ddc = NULL;
 
 	audio.hdmi      = hdmi;
-	audio.eld       = hdmi->connector.eld;
-	audio.write     = hdmi_writel;
-	audio.read      = hdmi_readl;
-	audio.mod       = hdmi_modb;
+	audio.write     = dw_hdmi_qp_write;
+	audio.read      = dw_hdmi_qp_read;
+	audio.mod       = dw_hdmi_qp_mod;
 	hdmi->enable_audio = dw_hdmi_i2s_audio_enable;
 	hdmi->disable_audio = dw_hdmi_i2s_audio_disable;
 
diff --git a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
index f98400ad4..d19a1ab51 100644
--- a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
+++ b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
@@ -348,6 +348,7 @@ dw_hdmi_rockchip_encoder_atomic_check(struct drm_encoder *encoder,
 	return 0;
 }
 
+/*
 static int dw_hdmi_dclk_set(void *data, bool enable)
 {
 	struct rockchip_hdmi *hdmi = (struct rockchip_hdmi *)data;
@@ -381,6 +382,7 @@ static int dw_hdmi_dclk_set(void *data, bool enable)
 
 	return 0;
 }
+*/
 
 static const struct drm_encoder_helper_funcs dw_hdmi_rockchip_encoder_helper_funcs = {
 	.mode_fixup = dw_hdmi_rockchip_encoder_mode_fixup,
@@ -609,7 +611,7 @@ static int dw_hdmi_rockchip_bind(struct device *dev, struct device *master,
 	plat_data->phy_data = hdmi;
 	plat_data->priv_data = hdmi;
 	encoder = &hdmi->encoder.encoder;
-	plat_data->dclk_set = dw_hdmi_dclk_set;
+	//plat_data->dclk_set = dw_hdmi_dclk_set;
 
 	encoder->possible_crtcs = drm_of_find_possible_crtcs(drm, dev->of_node);
 	rockchip_drm_encoder_set_crtc_endpoint_id(&hdmi->encoder,
diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index c66054087..287a59af0 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -13,6 +13,7 @@ struct drm_display_info;
 struct drm_display_mode;
 struct drm_encoder;
 struct dw_hdmi;
+struct dw_hdmi_qp;
 struct platform_device;
 
 /**
@@ -93,13 +94,6 @@ enum dw_hdmi_phy_type {
 	DW_HDMI_PHY_VENDOR_PHY = 0xfe,
 };
 
-struct dw_hdmi_audio_frl_n {
-	unsigned int r_bit;
-	unsigned int n_32k;
-	unsigned int n_44k1;
-	unsigned int n_48k;
-};
-
 struct dw_hdmi_mpll_config {
 	unsigned long mpixelclock;
 	struct {
@@ -225,23 +219,4 @@ void dw_hdmi_qp_resume(struct device *dev, struct dw_hdmi *hdmi);
 
 bool dw_hdmi_bus_fmt_is_420(struct dw_hdmi *hdmi);
 
-void dw_hdmi_qp_cec_set_hpd(struct dw_hdmi_qp *hdmi, bool plug_in, bool change);
-void dw_hdmi_qp_set_cec_adap(struct dw_hdmi_qp *hdmi, struct cec_adapter *adap);
-int dw_hdmi_qp_set_earc(struct dw_hdmi_qp *hdmi);
-void dw_hdmi_qp_set_sample_rate(struct dw_hdmi_qp *hdmi, unsigned int rate);
-void dw_hdmi_qp_set_channel_count(struct dw_hdmi_qp *hdmi, unsigned int cnt);
-void dw_hdmi_qp_set_channel_status(struct dw_hdmi_qp *hdmi, u8 *channel_status,
-				   bool ref2stream);
-void dw_hdmi_qp_set_channel_allocation(struct dw_hdmi_qp *hdmi, unsigned int ca);
-void dw_hdmi_qp_set_audio_interface(struct dw_hdmi_qp *hdmi,
-				    struct hdmi_codec_daifmt *fmt,
-				    struct hdmi_codec_params *hparms);
-void dw_hdmi_qp_set_audio_infoframe(struct dw_hdmi_qp *hdmi,
-				    struct hdmi_codec_params *hparms);
-void dw_hdmi_qp_audio_enable(struct dw_hdmi_qp *hdmi);
-void dw_hdmi_qp_audio_disable(struct dw_hdmi_qp *hdmi);
-bool dw_hdmi_qp_connected(struct dw_hdmi_qp *hdmi);
-int dw_hdmi_qp_set_plugged_cb(struct dw_hdmi_qp *hdmi, hdmi_codec_plugged_cb fn,
-			      struct device *codec_dev);
-
 #endif /* __IMX_HDMI_H__ */
diff --git a/include/drm/bridge/dw_hdmi_qp.h b/include/drm/bridge/dw_hdmi_qp.h
index 0b9c7a88a..033f95e57 100644
--- a/include/drm/bridge/dw_hdmi_qp.h
+++ b/include/drm/bridge/dw_hdmi_qp.h
@@ -7,6 +7,8 @@
 #ifndef __DW_HDMI_QP__
 #define __DW_HDMI_QP__
 
+#include <sound/hdmi-codec.h>
+
 struct device;
 struct drm_display_info;
 struct drm_encoder;
@@ -26,6 +28,20 @@ struct dw_hdmi_qp_plat_data {
 	void *phy_data;
 };
 
+struct dw_hdmi_audio_frl_n {
+	unsigned int r_bit;
+	unsigned int n_32k;
+	unsigned int n_44k1;
+	unsigned int n_48k;
+};
+
+struct dw_hdmi_audio_tmds_n {
+	unsigned long tmds;
+	unsigned int n_32k;
+	unsigned int n_44k1;
+	unsigned int n_48k;
+};
+
 void dw_hdmi_qp_set_high_tmds_clock_ratio(struct dw_hdmi_qp *hdmi,
 					  const struct drm_display_info *display);
 
@@ -34,4 +50,20 @@ struct dw_hdmi_qp *dw_hdmi_qp_bind(struct platform_device *pdev,
 				   struct drm_encoder *encoder,
 				   const struct dw_hdmi_qp_plat_data *plat_data);
 void dw_hdmi_qp_resume(struct device *dev, struct dw_hdmi_qp *hdmi);
+
+
+//void dw_hdmi_qp_set_sample_rate(struct dw_hdmi_qp *hdmi, unsigned int rate);
+void dw_hdmi_qp_set_channel_count(struct dw_hdmi_qp *hdmi, unsigned int cnt);
+void dw_hdmi_qp_set_channel_status(struct dw_hdmi_qp *hdmi, u8 *channel_status,
+				   bool ref2stream);
+void dw_hdmi_qp_set_channel_allocation(struct dw_hdmi_qp *hdmi, unsigned int ca);
+void dw_hdmi_qp_set_audio_interface(struct dw_hdmi_qp *hdmi,
+				    struct hdmi_codec_daifmt *fmt,
+				    struct hdmi_codec_params *hparms);
+void dw_hdmi_qp_set_audio_infoframe(struct dw_hdmi_qp *hdmi,
+				    struct hdmi_codec_params *hparms);
+void dw_hdmi_qp_audio_enable(struct dw_hdmi_qp *hdmi);
+void dw_hdmi_qp_audio_disable(struct dw_hdmi_qp *hdmi);
+bool dw_hdmi_qp_connected(struct dw_hdmi_qp *hdmi);
+
 #endif /* __DW_HDMI_QP__ */
-- 
2.46.0

