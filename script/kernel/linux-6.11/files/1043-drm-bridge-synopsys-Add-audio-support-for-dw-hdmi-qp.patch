From 5d136337a41f6ca4d08399e215d7a04f33fbc8d3 Mon Sep 17 00:00:00 2001
From: Sugar Zhang <sugar.zhang@rock-chips.com>
Date: Mon, 1 Nov 2021 14:28:52 +0800
Subject: [PATCH 82/94] drm/bridge: synopsys: Add audio support for dw-hdmi-qp

Signed-off-by: Sugar Zhang <sugar.zhang@rock-chips.com>
Change-Id: I41ceead79d46e08d5022bc1cc536af89437003a3
Signed-off-by: Detlev Casanova <detlev.casanova@collabora.com>

Gbp-Pq: Name 0163-drm-bridge-synopsys-Add-audio-support-for-dw-hdmi-qp.patch
---
 drivers/gpu/drm/bridge/synopsys/Makefile      |   2 +-
 .../drm/bridge/synopsys/dw-hdmi-qp-audio.h    |  29 ++
 .../bridge/synopsys/dw-hdmi-qp-i2s-audio.c    | 224 ++++++++++++
 drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c  | 321 ++++++++++++++++++
 include/drm/bridge/dw_hdmi.h                  |  11 +
 5 files changed, 586 insertions(+), 1 deletion(-)
 create mode 100644 drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-audio.h
 create mode 100644 drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-i2s-audio.c

diff --git a/drivers/gpu/drm/bridge/synopsys/Makefile b/drivers/gpu/drm/bridge/synopsys/Makefile
index 9869d9651..2d1379fe1 100644
--- a/drivers/gpu/drm/bridge/synopsys/Makefile
+++ b/drivers/gpu/drm/bridge/synopsys/Makefile
@@ -2,7 +2,7 @@
 obj-$(CONFIG_DRM_DW_HDMI) += dw-hdmi.o
 obj-$(CONFIG_DRM_DW_HDMI_AHB_AUDIO) += dw-hdmi-ahb-audio.o
 obj-$(CONFIG_DRM_DW_HDMI_GP_AUDIO) += dw-hdmi-gp-audio.o
-obj-$(CONFIG_DRM_DW_HDMI_I2S_AUDIO) += dw-hdmi-i2s-audio.o
+obj-$(CONFIG_DRM_DW_HDMI_I2S_AUDIO) += dw-hdmi-i2s-audio.o dw-hdmi-qp-i2s-audio.o
 obj-$(CONFIG_DRM_DW_HDMI_CEC) += dw-hdmi-cec.o
 
 obj-$(CONFIG_DRM_DW_HDMI_QP) += dw-hdmi-qp.o
diff --git a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-audio.h b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-audio.h
new file mode 100644
index 000000000..93f1a4295
--- /dev/null
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-audio.h
@@ -0,0 +1,29 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co. Ltd.
+ * Author: Sugar Zhang <sugar.zhang@rock-chips.com>
+ */
+
+#ifndef DW_HDMI_QP_AUDIO_H
+#define DW_HDMI_QP_AUDIO_H
+
+struct dw_hdmi_qp;
+
+struct dw_hdmi_qp_audio_data {
+	phys_addr_t phys;
+	void __iomem *base;
+	int irq;
+	struct dw_hdmi_qp *hdmi;
+	u8 *eld;
+};
+
+struct dw_hdmi_qp_i2s_audio_data {
+	struct dw_hdmi_qp *hdmi;
+	u8 *eld;
+
+	void (*write)(struct dw_hdmi_qp *hdmi, u32 val, int offset);
+	u32 (*read)(struct dw_hdmi_qp *hdmi, int offset);
+	void (*mod)(struct dw_hdmi_qp *hdmi, u32 val, u32 mask, u32 reg);
+};
+
+#endif
diff --git a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-i2s-audio.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-i2s-audio.c
new file mode 100644
index 000000000..c00712666
--- /dev/null
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-i2s-audio.c
@@ -0,0 +1,224 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * dw-hdmi-qp-i2s-audio.c
+ *
+ * Copyright (c) 2021 Rockchip Electronics Co. Ltd.
+ * Author: Sugar Zhang <sugar.zhang@rock-chips.com>
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/module.h>
+
+#include <drm/bridge/dw_hdmi.h>
+#include <drm/drm_crtc.h>
+
+#include <sound/hdmi-codec.h>
+
+#include "dw-hdmi-qp.h"
+#include "dw-hdmi-qp-audio.h"
+
+#define DRIVER_NAME "dw-hdmi-qp-i2s-audio"
+
+static inline void hdmi_write(struct dw_hdmi_qp_i2s_audio_data *audio,
+			      u32 val, int offset)
+{
+	struct dw_hdmi_qp *hdmi = audio->hdmi;
+
+	audio->write(hdmi, val, offset);
+}
+
+static inline u32 hdmi_read(struct dw_hdmi_qp_i2s_audio_data *audio, int offset)
+{
+	struct dw_hdmi_qp *hdmi = audio->hdmi;
+
+	return audio->read(hdmi, offset);
+}
+
+static inline void hdmi_mod(struct dw_hdmi_qp_i2s_audio_data *audio,
+			    u32 data, u32 mask, u32 reg)
+{
+	struct dw_hdmi_qp *hdmi = audio->hdmi;
+
+	return audio->mod(hdmi, data, mask, reg);
+}
+
+static int dw_hdmi_qp_i2s_hw_params(struct device *dev, void *data,
+				    struct hdmi_codec_daifmt *fmt,
+				    struct hdmi_codec_params *hparms)
+{
+	struct dw_hdmi_qp_i2s_audio_data *audio = data;
+	struct dw_hdmi_qp *hdmi = audio->hdmi;
+	u32 conf0 = 0;
+
+	if (fmt->bit_clk_provider | fmt->frame_clk_provider) {
+		dev_err(dev, "unsupported clock settings\n");
+		return -EINVAL;
+	}
+
+	/* Reset the audio data path of the AVP */
+	hdmi_write(audio, AVP_DATAPATH_PACKET_AUDIO_SWINIT_P, GLOBAL_SWRESET_REQUEST);
+
+	/* Clear the audio FIFO */
+	hdmi_write(audio, AUDIO_FIFO_CLR_P, AUDIO_INTERFACE_CONTROL0);
+
+	/* Disable AUDS, ACR, AUDI, AMD */
+	hdmi_mod(audio, 0,
+		 PKTSCHED_ACR_TX_EN | PKTSCHED_AUDS_TX_EN |
+		 PKTSCHED_AUDI_TX_EN | PKTSCHED_AMD_TX_EN,
+		 PKTSCHED_PKT_EN);
+
+	/* Select I2S interface as the audio source */
+	hdmi_mod(audio, AUD_IF_I2S, AUD_IF_SEL_MSK, AUDIO_INTERFACE_CONFIG0);
+
+	/* Enable the active i2s lanes */
+	switch (hparms->channels) {
+	case 7 ... 8:
+		conf0 |= I2S_LINES_EN(3);
+		fallthrough;
+	case 5 ... 6:
+		conf0 |= I2S_LINES_EN(2);
+		fallthrough;
+	case 3 ... 4:
+		conf0 |= I2S_LINES_EN(1);
+		fallthrough;
+	default:
+		conf0 |= I2S_LINES_EN(0);
+		break;
+	}
+
+	hdmi_mod(audio, conf0, I2S_LINES_EN_MSK, AUDIO_INTERFACE_CONFIG0);
+
+	/* Enable bpcuv generated internally */
+	hdmi_mod(audio, I2S_BPCUV_RCV_DIS, I2S_BPCUV_RCV_MSK, AUDIO_INTERFACE_CONFIG0);
+
+	/* Configure the audio format */
+	hdmi_mod(audio, AUD_ASP, AUD_FORMAT_MSK, AUDIO_INTERFACE_CONFIG0);
+
+	/* Enable audio FIFO auto clear when overflow */
+	hdmi_mod(audio, AUD_FIFO_INIT_ON_OVF_EN, AUD_FIFO_INIT_ON_OVF_MSK,
+		 AUDIO_INTERFACE_CONFIG0);
+
+	dw_hdmi_qp_set_sample_rate(hdmi, hparms->sample_rate);
+	dw_hdmi_qp_set_channel_status(hdmi, hparms->iec.status);
+	dw_hdmi_qp_set_channel_count(hdmi, hparms->channels);
+	dw_hdmi_qp_set_channel_allocation(hdmi, hparms->cea.channel_allocation);
+
+	/* Enable ACR, AUDI, AMD */
+	hdmi_mod(audio,
+		 PKTSCHED_ACR_TX_EN | PKTSCHED_AUDI_TX_EN | PKTSCHED_AMD_TX_EN,
+		 PKTSCHED_ACR_TX_EN | PKTSCHED_AUDI_TX_EN | PKTSCHED_AMD_TX_EN,
+		 PKTSCHED_PKT_EN);
+
+	/* Enable AUDS */
+	hdmi_mod(audio, PKTSCHED_AUDS_TX_EN, PKTSCHED_AUDS_TX_EN, PKTSCHED_PKT_EN);
+
+	return 0;
+}
+
+static int dw_hdmi_qp_i2s_audio_startup(struct device *dev, void *data)
+{
+	struct dw_hdmi_qp_i2s_audio_data *audio = data;
+	struct dw_hdmi_qp *hdmi = audio->hdmi;
+
+	dw_hdmi_qp_audio_enable(hdmi);
+
+	return 0;
+}
+
+static void dw_hdmi_qp_i2s_audio_shutdown(struct device *dev, void *data)
+{
+	struct dw_hdmi_qp_i2s_audio_data *audio = data;
+	struct dw_hdmi_qp *hdmi = audio->hdmi;
+
+	dw_hdmi_qp_audio_disable(hdmi);
+}
+
+static int dw_hdmi_qp_i2s_get_eld(struct device *dev, void *data, uint8_t *buf,
+				  size_t len)
+{
+	struct dw_hdmi_qp_i2s_audio_data *audio = data;
+
+	memcpy(buf, audio->eld, min_t(size_t, MAX_ELD_BYTES, len));
+
+	return 0;
+}
+
+static int dw_hdmi_qp_i2s_get_dai_id(struct snd_soc_component *component,
+				     struct device_node *endpoint)
+{
+	struct of_endpoint of_ep;
+	int ret;
+
+	ret = of_graph_parse_endpoint(endpoint, &of_ep);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * HDMI sound should be located as reg = <2>
+	 * Then, it is sound port 0
+	 */
+	if (of_ep.port == 2)
+		return 0;
+
+	return -EINVAL;
+}
+
+static struct hdmi_codec_ops dw_hdmi_qp_i2s_ops = {
+	.hw_params	= dw_hdmi_qp_i2s_hw_params,
+	.audio_startup  = dw_hdmi_qp_i2s_audio_startup,
+	.audio_shutdown	= dw_hdmi_qp_i2s_audio_shutdown,
+	.get_eld	= dw_hdmi_qp_i2s_get_eld,
+	.get_dai_id	= dw_hdmi_qp_i2s_get_dai_id,
+};
+
+static int snd_dw_hdmi_qp_probe(struct platform_device *pdev)
+{
+	struct dw_hdmi_qp_i2s_audio_data *audio = pdev->dev.platform_data;
+	struct platform_device_info pdevinfo;
+	struct hdmi_codec_pdata pdata;
+	struct platform_device *platform;
+
+	pdata.ops		= &dw_hdmi_qp_i2s_ops;
+	pdata.i2s		= 1;
+	pdata.max_i2s_channels	= 8;
+	pdata.data		= audio;
+
+	memset(&pdevinfo, 0, sizeof(pdevinfo));
+	pdevinfo.parent		= pdev->dev.parent;
+	pdevinfo.id		= PLATFORM_DEVID_AUTO;
+	pdevinfo.name		= HDMI_CODEC_DRV_NAME;
+	pdevinfo.data		= &pdata;
+	pdevinfo.size_data	= sizeof(pdata);
+	pdevinfo.dma_mask	= DMA_BIT_MASK(32);
+
+	platform = platform_device_register_full(&pdevinfo);
+	if (IS_ERR(platform))
+		return PTR_ERR(platform);
+
+	dev_set_drvdata(&pdev->dev, platform);
+
+	return 0;
+}
+
+static int snd_dw_hdmi_qp_remove(struct platform_device *pdev)
+{
+	struct platform_device *platform = dev_get_drvdata(&pdev->dev);
+
+	platform_device_unregister(platform);
+
+	return 0;
+}
+
+static struct platform_driver snd_dw_hdmi_qp_driver = {
+	.probe	= snd_dw_hdmi_qp_probe,
+	.remove	= snd_dw_hdmi_qp_remove,
+	.driver	= {
+		.name = DRIVER_NAME,
+	},
+};
+module_platform_driver(snd_dw_hdmi_qp_driver);
+
+MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
+MODULE_DESCRIPTION("Synopsis Designware HDMI QP I2S ALSA SoC interface");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff --git a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c
index 84706fed4..10a90527e 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c
@@ -29,6 +29,7 @@
 
 #include <sound/hdmi-codec.h>
 
+#include "dw-hdmi-qp-audio.h"
 #include "dw-hdmi-qp.h"
 
 #define DDC_CI_ADDR		0x37
@@ -52,6 +53,61 @@ struct dw_hdmi_qp_cec {
 };
 #endif
 
+/*
+ * Unless otherwise noted, entries in this table are 100% optimization.
+ * Values can be obtained from hdmi_compute_n() but that function is
+ * slow so we pre-compute values we expect to see.
+ *
+ * All 32k and 48k values are expected to be the same (due to the way
+ * the math works) for any rate that's an exact kHz.
+ */
+static const struct dw_hdmi_audio_tmds_n common_tmds_n_table[] = {
+	{ .tmds = 25175000, .n_32k = 4096, .n_44k1 = 12854, .n_48k = 6144, },
+	{ .tmds = 25200000, .n_32k = 4096, .n_44k1 = 5656, .n_48k = 6144, },
+	{ .tmds = 27000000, .n_32k = 4096, .n_44k1 = 5488, .n_48k = 6144, },
+	{ .tmds = 28320000, .n_32k = 4096, .n_44k1 = 5586, .n_48k = 6144, },
+	{ .tmds = 30240000, .n_32k = 4096, .n_44k1 = 5642, .n_48k = 6144, },
+	{ .tmds = 31500000, .n_32k = 4096, .n_44k1 = 5600, .n_48k = 6144, },
+	{ .tmds = 32000000, .n_32k = 4096, .n_44k1 = 5733, .n_48k = 6144, },
+	{ .tmds = 33750000, .n_32k = 4096, .n_44k1 = 6272, .n_48k = 6144, },
+	{ .tmds = 36000000, .n_32k = 4096, .n_44k1 = 5684, .n_48k = 6144, },
+	{ .tmds = 40000000, .n_32k = 4096, .n_44k1 = 5733, .n_48k = 6144, },
+	{ .tmds = 49500000, .n_32k = 4096, .n_44k1 = 5488, .n_48k = 6144, },
+	{ .tmds = 50000000, .n_32k = 4096, .n_44k1 = 5292, .n_48k = 6144, },
+	{ .tmds = 54000000, .n_32k = 4096, .n_44k1 = 5684, .n_48k = 6144, },
+	{ .tmds = 65000000, .n_32k = 4096, .n_44k1 = 7056, .n_48k = 6144, },
+	{ .tmds = 68250000, .n_32k = 4096, .n_44k1 = 5376, .n_48k = 6144, },
+	{ .tmds = 71000000, .n_32k = 4096, .n_44k1 = 7056, .n_48k = 6144, },
+	{ .tmds = 72000000, .n_32k = 4096, .n_44k1 = 5635, .n_48k = 6144, },
+	{ .tmds = 73250000, .n_32k = 4096, .n_44k1 = 14112, .n_48k = 6144, },
+	{ .tmds = 74250000, .n_32k = 4096, .n_44k1 = 6272, .n_48k = 6144, },
+	{ .tmds = 75000000, .n_32k = 4096, .n_44k1 = 5880, .n_48k = 6144, },
+	{ .tmds = 78750000, .n_32k = 4096, .n_44k1 = 5600, .n_48k = 6144, },
+	{ .tmds = 78800000, .n_32k = 4096, .n_44k1 = 5292, .n_48k = 6144, },
+	{ .tmds = 79500000, .n_32k = 4096, .n_44k1 = 4704, .n_48k = 6144, },
+	{ .tmds = 83500000, .n_32k = 4096, .n_44k1 = 7056, .n_48k = 6144, },
+	{ .tmds = 85500000, .n_32k = 4096, .n_44k1 = 5488, .n_48k = 6144, },
+	{ .tmds = 88750000, .n_32k = 4096, .n_44k1 = 14112, .n_48k = 6144, },
+	{ .tmds = 97750000, .n_32k = 4096, .n_44k1 = 14112, .n_48k = 6144, },
+	{ .tmds = 101000000, .n_32k = 4096, .n_44k1 = 7056, .n_48k = 6144, },
+	{ .tmds = 106500000, .n_32k = 4096, .n_44k1 = 4704, .n_48k = 6144, },
+	{ .tmds = 108000000, .n_32k = 4096, .n_44k1 = 5684, .n_48k = 6144, },
+	{ .tmds = 115500000, .n_32k = 4096, .n_44k1 = 5712, .n_48k = 6144, },
+	{ .tmds = 119000000, .n_32k = 4096, .n_44k1 = 5544, .n_48k = 6144, },
+	{ .tmds = 135000000, .n_32k = 4096, .n_44k1 = 5488, .n_48k = 6144, },
+	{ .tmds = 146250000, .n_32k = 4096, .n_44k1 = 6272, .n_48k = 6144, },
+	{ .tmds = 148500000, .n_32k = 4096, .n_44k1 = 5488, .n_48k = 6144, },
+	{ .tmds = 154000000, .n_32k = 4096, .n_44k1 = 5544, .n_48k = 6144, },
+	{ .tmds = 162000000, .n_32k = 4096, .n_44k1 = 5684, .n_48k = 6144, },
+
+	/* For 297 MHz+ HDMI spec have some other rule for setting N */
+	{ .tmds = 297000000, .n_32k = 3073, .n_44k1 = 4704, .n_48k = 5120, },
+	{ .tmds = 594000000, .n_32k = 3073, .n_44k1 = 9408, .n_48k = 10240, },
+
+	/* End of table */
+	{ .tmds = 0,         .n_32k = 0,    .n_44k1 = 0,    .n_48k = 0, },
+};
+
 struct dw_hdmi_qp_i2c {
 	struct i2c_adapter	adap;
 
@@ -82,9 +138,245 @@ struct dw_hdmi_qp {
 	struct drm_connector *curr_conn;
 	unsigned long long pix_clock;
 
+	spinlock_t audio_lock;
+	struct mutex audio_mutex;
+	unsigned int sample_rate;
+	unsigned int audio_cts;
+	unsigned int audio_n;
+	bool audio_enable;
+	void (*enable_audio)(struct dw_hdmi_qp *hdmi);
+	void (*disable_audio)(struct dw_hdmi_qp *hdmi);
+
 	struct regmap *regm;
 };
 
+static void hdmi_set_cts_n(struct dw_hdmi_qp *hdmi, unsigned int cts,
+			   unsigned int n)
+{
+	/* Set N */
+	hdmi_modb(hdmi, n, AUDPKT_ACR_N_VALUE, AUDPKT_ACR_CONTROL0);
+
+	/* Set CTS */
+	if (cts)
+		hdmi_modb(hdmi, AUDPKT_ACR_CTS_OVR_EN, AUDPKT_ACR_CTS_OVR_EN_MSK,
+			  AUDPKT_ACR_CONTROL1);
+	else
+		hdmi_modb(hdmi, 0, AUDPKT_ACR_CTS_OVR_EN_MSK,
+			  AUDPKT_ACR_CONTROL1);
+
+	hdmi_modb(hdmi, AUDPKT_ACR_CTS_OVR_VAL(cts), AUDPKT_ACR_CTS_OVR_VAL_MSK,
+		  AUDPKT_ACR_CONTROL1);
+}
+
+static int hdmi_match_tmds_n_table(struct dw_hdmi_qp *hdmi,
+				   unsigned long pixel_clk,
+				   unsigned long freq)
+{
+	const struct dw_hdmi_audio_tmds_n *tmds_n = NULL;
+	int i;
+
+	for (i = 0; common_tmds_n_table[i].tmds != 0; i++) {
+		if (pixel_clk == common_tmds_n_table[i].tmds) {
+			tmds_n = &common_tmds_n_table[i];
+			break;
+		}
+	}
+
+	if (tmds_n == NULL)
+		return -ENOENT;
+
+	switch (freq) {
+	case 32000:
+		return tmds_n->n_32k;
+	case 44100:
+	case 88200:
+	case 176400:
+		return (freq / 44100) * tmds_n->n_44k1;
+	case 48000:
+	case 96000:
+	case 192000:
+		return (freq / 48000) * tmds_n->n_48k;
+	default:
+		return -ENOENT;
+	}
+}
+
+static u64 hdmi_audio_math_diff(unsigned int freq, unsigned int n,
+				unsigned int pixel_clk)
+{
+	u64 final, diff;
+	u64 cts;
+
+	final = (u64)pixel_clk * n;
+
+	cts = final;
+	do_div(cts, 128 * freq);
+
+	diff = final - (u64)cts * (128 * freq);
+
+	return diff;
+}
+
+static unsigned int hdmi_compute_n(struct dw_hdmi_qp *hdmi,
+				   unsigned long pixel_clk,
+				   unsigned long freq)
+{
+	unsigned int min_n = DIV_ROUND_UP((128 * freq), 1500);
+	unsigned int max_n = (128 * freq) / 300;
+	unsigned int ideal_n = (128 * freq) / 1000;
+	unsigned int best_n_distance = ideal_n;
+	unsigned int best_n = 0;
+	u64 best_diff = U64_MAX;
+	int n;
+
+	/* If the ideal N could satisfy the audio math, then just take it */
+	if (hdmi_audio_math_diff(freq, ideal_n, pixel_clk) == 0)
+		return ideal_n;
+
+	for (n = min_n; n <= max_n; n++) {
+		u64 diff = hdmi_audio_math_diff(freq, n, pixel_clk);
+
+		if (diff < best_diff || (diff == best_diff &&
+		    abs(n - ideal_n) < best_n_distance)) {
+			best_n = n;
+			best_diff = diff;
+			best_n_distance = abs(best_n - ideal_n);
+		}
+
+		/*
+		 * The best N already satisfy the audio math, and also be
+		 * the closest value to ideal N, so just cut the loop.
+		 */
+		if ((best_diff == 0) && (abs(n - ideal_n) > best_n_distance))
+			break;
+	}
+
+	return best_n;
+}
+
+static unsigned int hdmi_find_n(struct dw_hdmi_qp *hdmi, unsigned long pixel_clk,
+				unsigned long sample_rate)
+{
+	int n;
+
+	n = hdmi_match_tmds_n_table(hdmi, pixel_clk, sample_rate);
+	if (n > 0)
+		return n;
+
+	dev_warn(hdmi->dev, "Rate %lu missing; compute N dynamically\n",
+		 pixel_clk);
+
+	return hdmi_compute_n(hdmi, pixel_clk, sample_rate);
+}
+
+/*
+ * When transmitting IEC60958 linear PCM audio, these registers allow to
+ * configure the channel status information of all the channel status
+ * bits in the IEC60958 frame. For the moment this configuration is only
+ * used when the I2S audio interface, General Purpose Audio (GPA),
+ * or AHB audio DMA (AHBAUDDMA) interface is active
+ * (for S/PDIF interface this information comes from the stream).
+ */
+void dw_hdmi_qp_set_channel_status(struct dw_hdmi_qp *hdmi,
+				   u8 *channel_status)
+{
+}
+EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_channel_status);
+
+static void hdmi_set_clk_regenerator(struct dw_hdmi_qp *hdmi,
+	unsigned long pixel_clk, unsigned int sample_rate)
+{
+	unsigned int n = 0, cts = 0;
+
+	n = hdmi_find_n(hdmi, pixel_clk, sample_rate);
+
+	spin_lock_irq(&hdmi->audio_lock);
+	hdmi->audio_n = n;
+	hdmi->audio_cts = cts;
+	hdmi_set_cts_n(hdmi, cts, hdmi->audio_enable ? n : 0);
+	spin_unlock_irq(&hdmi->audio_lock);
+}
+
+static void hdmi_init_clk_regenerator(struct dw_hdmi_qp *hdmi)
+{
+	mutex_lock(&hdmi->audio_mutex);
+	hdmi_set_clk_regenerator(hdmi, 74250000, hdmi->sample_rate);
+	mutex_unlock(&hdmi->audio_mutex);
+}
+
+static void hdmi_clk_regenerator_update_pixel_clock(struct dw_hdmi_qp *hdmi)
+{
+	mutex_lock(&hdmi->audio_mutex);
+	hdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,
+				 hdmi->sample_rate);
+	mutex_unlock(&hdmi->audio_mutex);
+}
+
+void dw_hdmi_qp_set_sample_rate(struct dw_hdmi_qp *hdmi, unsigned int rate)
+{
+	mutex_lock(&hdmi->audio_mutex);
+	hdmi->sample_rate = rate;
+	hdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,
+				 hdmi->sample_rate);
+	mutex_unlock(&hdmi->audio_mutex);
+}
+EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_sample_rate);
+
+void dw_hdmi_qp_set_channel_count(struct dw_hdmi_qp *hdmi, unsigned int cnt)
+{
+}
+EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_channel_count);
+
+void dw_hdmi_qp_set_channel_allocation(struct dw_hdmi_qp *hdmi, unsigned int ca)
+{
+}
+EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_channel_allocation);
+
+static void hdmi_enable_audio_clk(struct dw_hdmi_qp *hdmi, bool enable)
+{
+	if (enable)
+		hdmi_modb(hdmi, 0,
+			  AVP_DATAPATH_PACKET_AUDIO_SWDISABLE, GLOBAL_SWDISABLE);
+	else
+		hdmi_modb(hdmi, AVP_DATAPATH_PACKET_AUDIO_SWDISABLE,
+			  AVP_DATAPATH_PACKET_AUDIO_SWDISABLE, GLOBAL_SWDISABLE);
+}
+
+static void dw_hdmi_i2s_audio_enable(struct dw_hdmi_qp *hdmi)
+{
+	hdmi_set_cts_n(hdmi, hdmi->audio_cts, hdmi->audio_n);
+	hdmi_enable_audio_clk(hdmi, true);
+}
+
+static void dw_hdmi_i2s_audio_disable(struct dw_hdmi_qp *hdmi)
+{
+	hdmi_enable_audio_clk(hdmi, false);
+}
+
+void dw_hdmi_qp_audio_enable(struct dw_hdmi_qp *hdmi)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&hdmi->audio_lock, flags);
+	hdmi->audio_enable = true;
+	if (hdmi->enable_audio)
+		hdmi->enable_audio(hdmi);
+	spin_unlock_irqrestore(&hdmi->audio_lock, flags);
+}
+EXPORT_SYMBOL_GPL(dw_hdmi_qp_audio_enable);
+
+void dw_hdmi_qp_audio_disable(struct dw_hdmi_qp *hdmi)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&hdmi->audio_lock, flags);
+	hdmi->audio_enable = false;
+	if (hdmi->disable_audio)
+		hdmi->disable_audio(hdmi);
+	spin_unlock_irqrestore(&hdmi->audio_lock, flags);
+}
+EXPORT_SYMBOL_GPL(dw_hdmi_qp_audio_disable);
+
 /* Filter out invalid setups to avoid configuring SCDC and scrambling */
 static bool dw_hdmi_qp_support_scdc(struct dw_hdmi_qp *hdmi,
 				    const struct drm_display_info *display)
@@ -697,6 +989,10 @@ static void dw_hdmi_qp_setup(struct dw_hdmi_qp *hdmi,
 		return;
 	}
 
+	/* HDMI Initialization Step E - Configure audio */
+	hdmi_clk_regenerator_update_pixel_clock(hdmi);
+	hdmi_enable_audio_clk(hdmi, hdmi->audio_enable);
+
 	dev_dbg(hdmi->dev, "%s HDMI mode\n", __func__);
 
 	dw_hdmi_qp_mod(hdmi, 0, OPMODE_DVI, LINK_CONFIG0);
@@ -929,6 +1225,8 @@ struct dw_hdmi_qp *dw_hdmi_qp_bind(struct platform_device *pdev,
 {
 	struct device *dev = &pdev->dev;
 	struct dw_hdmi_qp *hdmi;
+	struct dw_hdmi_qp_i2s_audio_data audio;
+	struct platform_device_info pdevinfo;
 	void __iomem *regs;
 	int irq, ret;
 
@@ -943,6 +1241,10 @@ struct dw_hdmi_qp *dw_hdmi_qp_bind(struct platform_device *pdev,
 		return ERR_PTR(-ENOMEM);
 
 	hdmi->dev = dev;
+	hdmi->sample_rate = 48000;
+
+	mutex_init(&hdmi->audio_mutex);
+	spin_lock_init(&hdmi->audio_lock);
 
 	regs = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(regs))
@@ -974,6 +1276,8 @@ struct dw_hdmi_qp *dw_hdmi_qp_bind(struct platform_device *pdev,
 	if (ret)
 		return ERR_PTR(ret);
 
+	hdmi_init_clk_regenerator(hdmi);
+
 	hdmi->bridge.max_bpc = 10;
 	hdmi->bridge.driver_private = hdmi;
 	hdmi->bridge.funcs = &dw_hdmi_qp_bridge_funcs;
@@ -994,6 +1298,23 @@ struct dw_hdmi_qp *dw_hdmi_qp_bind(struct platform_device *pdev,
 	if (IS_ERR(hdmi->bridge.ddc))
 		hdmi->bridge.ddc = NULL;
 
+	audio.hdmi      = hdmi;
+	audio.eld       = hdmi->connector.eld;
+	audio.write     = hdmi_writel;
+	audio.read      = hdmi_readl;
+	audio.mod       = hdmi_modb;
+	hdmi->enable_audio = dw_hdmi_i2s_audio_enable;
+	hdmi->disable_audio = dw_hdmi_i2s_audio_disable;
+
+	memset(&pdevinfo, 0, sizeof(pdevinfo));
+	pdevinfo.parent = dev;
+	pdevinfo.id = PLATFORM_DEVID_AUTO;
+	pdevinfo.name = "dw-hdmi-qp-i2s-audio";
+	pdevinfo.data = &audio;
+	pdevinfo.size_data = sizeof(audio);
+	pdevinfo.dma_mask = DMA_BIT_MASK(32);
+	hdmi->audio = platform_device_register_full(&pdevinfo);
+
 	ret = devm_drm_bridge_add(dev, &hdmi->bridge);
 	if (ret)
 		return ERR_PTR(ret);
diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index a9cc46042..fa9239b57 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -7,6 +7,7 @@
 #define __DW_HDMI__
 
 #include <sound/hdmi-codec.h>
+#include <media/cec.h>
 
 struct drm_display_info;
 struct drm_display_mode;
@@ -216,4 +217,14 @@ void dw_hdmi_qp_resume(struct device *dev, struct dw_hdmi *hdmi);
 
 bool dw_hdmi_bus_fmt_is_420(struct dw_hdmi *hdmi);
 
+void dw_hdmi_qp_cec_set_hpd(struct dw_hdmi_qp *hdmi, bool plug_in, bool change);
+void dw_hdmi_qp_set_cec_adap(struct dw_hdmi_qp *hdmi, struct cec_adapter *adap);
+int dw_hdmi_qp_set_earc(struct dw_hdmi_qp *hdmi);
+void dw_hdmi_qp_set_sample_rate(struct dw_hdmi_qp *hdmi, unsigned int rate);
+void dw_hdmi_qp_set_channel_count(struct dw_hdmi_qp *hdmi, unsigned int cnt);
+void dw_hdmi_qp_set_channel_status(struct dw_hdmi_qp *hdmi, u8 *channel_status);
+void dw_hdmi_qp_set_channel_allocation(struct dw_hdmi_qp *hdmi, unsigned int ca);
+void dw_hdmi_qp_audio_enable(struct dw_hdmi_qp *hdmi);
+void dw_hdmi_qp_audio_disable(struct dw_hdmi_qp *hdmi);
+
 #endif /* __IMX_HDMI_H__ */
-- 
2.46.0

