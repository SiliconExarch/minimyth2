From 25ff40edb0a0c8550e701bec2404be35f5373f63 Mon Sep 17 00:00:00 2001
From: Algea Cao <algea.cao@rock-chips.com>
Date: Thu, 24 Feb 2022 11:05:56 +0800
Subject: [PATCH 85/94] drm/rockchip: dw_hdmi: Make sure dclk is enabled when
 set audio registers

Change-Id: Idb62c2c9ea0d75d7090ec3e35c7742b0d42b3e43
Signed-off-by: Algea Cao <algea.cao@rock-chips.com>
Signed-off-by: Sugar Zhang <sugar.zhang@rock-chips.com>
Signed-off-by: Detlev Casanova <detlev.casanova@collabora.com>

Gbp-Pq: Name 0166-drm-rockchip-dw_hdmi-Make-sure-dclk-is-enabled-when-.patch
---
 .../bridge/synopsys/dw-hdmi-qp-i2s-audio.c    |  16 +--
 drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c  | 106 ++++++++++++++----
 drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c   |  35 ++++++
 include/drm/bridge/dw_hdmi.h                  |   2 +
 4 files changed, 120 insertions(+), 39 deletions(-)

diff --git a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-i2s-audio.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-i2s-audio.c
index 1166b1c16..fc1208a27 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-i2s-audio.c
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-i2s-audio.c
@@ -71,12 +71,6 @@ static int dw_hdmi_qp_i2s_hw_params(struct device *dev, void *data,
 	/* Clear the audio FIFO */
 	hdmi_write(audio, AUDIO_FIFO_CLR_P, AUDIO_INTERFACE_CONTROL0);
 
-	/* Disable AUDS, ACR, AUDI, AMD */
-	hdmi_mod(audio, 0,
-		 PKTSCHED_ACR_TX_EN | PKTSCHED_AUDS_TX_EN |
-		 PKTSCHED_AUDI_TX_EN | PKTSCHED_AMD_TX_EN,
-		 PKTSCHED_PKT_EN);
-
 	/* Select I2S interface as the audio source */
 	hdmi_mod(audio, AUD_IF_I2S, AUD_IF_SEL_MSK, AUDIO_INTERFACE_CONFIG0);
 
@@ -123,15 +117,7 @@ static int dw_hdmi_qp_i2s_hw_params(struct device *dev, void *data,
 	dw_hdmi_qp_set_channel_status(hdmi, hparms->iec.status);
 	dw_hdmi_qp_set_channel_count(hdmi, hparms->channels);
 	dw_hdmi_qp_set_channel_allocation(hdmi, hparms->cea.channel_allocation);
-
-	/* Enable ACR, AUDI, AMD */
-	hdmi_mod(audio,
-		 PKTSCHED_ACR_TX_EN | PKTSCHED_AUDI_TX_EN | PKTSCHED_AMD_TX_EN,
-		 PKTSCHED_ACR_TX_EN | PKTSCHED_AUDI_TX_EN | PKTSCHED_AMD_TX_EN,
-		 PKTSCHED_PKT_EN);
-
-	/* Enable AUDS */
-	hdmi_mod(audio, PKTSCHED_AUDS_TX_EN, PKTSCHED_AUDS_TX_EN, PKTSCHED_PKT_EN);
+	dw_hdmi_qp_set_audio_infoframe(hdmi);
 
 	return 0;
 }
diff --git a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c
index 89e35948f..a5d7ff0b6 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c
@@ -138,7 +138,6 @@ struct dw_hdmi_qp {
 	struct drm_connector *curr_conn;
 	unsigned long long pix_clock;
 
-	spinlock_t audio_lock;
 	struct mutex audio_mutex;
 	unsigned int sample_rate;
 	unsigned int audio_cts;
@@ -280,11 +279,19 @@ static unsigned int hdmi_find_n(struct dw_hdmi_qp *hdmi, unsigned long pixel_clk
 void dw_hdmi_qp_set_channel_status(struct dw_hdmi_qp *hdmi,
 				   u8 *channel_status)
 {
+	mutex_lock(&hdmi->audio_mutex);
+	if (!hdmi->dclk_en) {
+		mutex_unlock(&hdmi->audio_mutex);
+		return;
+	}
+
 	/* Set channel status */
 	hdmi_writel(hdmi, channel_status[3] | (channel_status[4] << 8),
 		    AUDPKT_CHSTATUS_OVR1);
 	hdmi_modb(hdmi, AUDPKT_CHSTATUS_OVR_EN,
 		  AUDPKT_CHSTATUS_OVR_EN_MASK, AUDPKT_CONTROL0);
+
+	mutex_unlock(&hdmi->audio_mutex);
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_channel_status);
 
@@ -295,34 +302,36 @@ static void hdmi_set_clk_regenerator(struct dw_hdmi_qp *hdmi,
 
 	n = hdmi_find_n(hdmi, pixel_clk, sample_rate);
 
-	spin_lock_irq(&hdmi->audio_lock);
 	hdmi->audio_n = n;
 	hdmi->audio_cts = cts;
 	hdmi_set_cts_n(hdmi, cts, hdmi->audio_enable ? n : 0);
-	spin_unlock_irq(&hdmi->audio_lock);
 }
 
 static void hdmi_init_clk_regenerator(struct dw_hdmi_qp *hdmi)
 {
 	mutex_lock(&hdmi->audio_mutex);
-	hdmi_set_clk_regenerator(hdmi, 74250000, hdmi->sample_rate);
+	if (hdmi->dclk_en)
+		hdmi_set_clk_regenerator(hdmi, 74250000, hdmi->sample_rate);
 	mutex_unlock(&hdmi->audio_mutex);
 }
 
 static void hdmi_clk_regenerator_update_pixel_clock(struct dw_hdmi_qp *hdmi)
 {
 	mutex_lock(&hdmi->audio_mutex);
-	hdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,
-				 hdmi->sample_rate);
+	if (hdmi->dclk_en)
+		hdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,
+					 hdmi->sample_rate);
 	mutex_unlock(&hdmi->audio_mutex);
 }
 
 void dw_hdmi_qp_set_sample_rate(struct dw_hdmi_qp *hdmi, unsigned int rate)
 {
 	mutex_lock(&hdmi->audio_mutex);
-	hdmi->sample_rate = rate;
-	hdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,
-				 hdmi->sample_rate);
+	if (hdmi->dclk_en) {
+		hdmi->sample_rate = rate;
+		hdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,
+					 hdmi->sample_rate);
+	}
 	mutex_unlock(&hdmi->audio_mutex);
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_sample_rate);
@@ -337,6 +346,26 @@ void dw_hdmi_qp_set_channel_allocation(struct dw_hdmi_qp *hdmi, unsigned int ca)
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_channel_allocation);
 
+void dw_hdmi_qp_set_audio_infoframe(struct dw_hdmi_qp *hdmi)
+{
+	mutex_lock(&hdmi->audio_mutex);
+	if (!hdmi->dclk_en) {
+		mutex_unlock(&hdmi->audio_mutex);
+		return;
+	}
+
+	/* Enable ACR, AUDI, AMD */
+	hdmi_modb(hdmi,
+		  PKTSCHED_ACR_TX_EN | PKTSCHED_AUDI_TX_EN | PKTSCHED_AMD_TX_EN,
+		  PKTSCHED_ACR_TX_EN | PKTSCHED_AUDI_TX_EN | PKTSCHED_AMD_TX_EN,
+		  PKTSCHED_PKT_EN);
+
+	/* Enable AUDS */
+	hdmi_modb(hdmi, PKTSCHED_AUDS_TX_EN, PKTSCHED_AUDS_TX_EN, PKTSCHED_PKT_EN);
+	mutex_unlock(&hdmi->audio_mutex);
+}
+EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_audio_infoframe);
+
 static void hdmi_enable_audio_clk(struct dw_hdmi_qp *hdmi, bool enable)
 {
 	if (enable)
@@ -355,30 +384,36 @@ static void dw_hdmi_i2s_audio_enable(struct dw_hdmi_qp *hdmi)
 
 static void dw_hdmi_i2s_audio_disable(struct dw_hdmi_qp *hdmi)
 {
+	/* Disable AUDS, ACR, AUDI, AMD */
+	hdmi_modb(hdmi, 0,
+		  PKTSCHED_ACR_TX_EN | PKTSCHED_AUDS_TX_EN |
+		  PKTSCHED_AUDI_TX_EN | PKTSCHED_AMD_TX_EN,
+		  PKTSCHED_PKT_EN);
+
 	hdmi_enable_audio_clk(hdmi, false);
 }
 
 void dw_hdmi_qp_audio_enable(struct dw_hdmi_qp *hdmi)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&hdmi->audio_lock, flags);
-	hdmi->audio_enable = true;
-	if (hdmi->enable_audio)
-		hdmi->enable_audio(hdmi);
-	spin_unlock_irqrestore(&hdmi->audio_lock, flags);
+	mutex_lock(&hdmi->audio_mutex);
+	if (hdmi->dclk_en) {
+		hdmi->audio_enable = true;
+		if (hdmi->enable_audio)
+			hdmi->enable_audio(hdmi);
+	}
+	mutex_unlock(&hdmi->audio_mutex);
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_qp_audio_enable);
 
 void dw_hdmi_qp_audio_disable(struct dw_hdmi_qp *hdmi)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&hdmi->audio_lock, flags);
-	hdmi->audio_enable = false;
-	if (hdmi->disable_audio)
-		hdmi->disable_audio(hdmi);
-	spin_unlock_irqrestore(&hdmi->audio_lock, flags);
+	mutex_lock(&hdmi->audio_mutex);
+	if (hdmi->dclk_en) {
+		hdmi->audio_enable = false;
+		if (hdmi->disable_audio)
+			hdmi->disable_audio(hdmi);
+	}
+	mutex_unlock(&hdmi->audio_mutex);
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_qp_audio_disable);
 
@@ -1065,12 +1100,36 @@ static void dw_hdmi_qp_bridge_atomic_enable(struct drm_bridge *bridge,
 	dw_hdmi_qp_setup(hdmi, connector);
 
 	drm_atomic_helper_connector_hdmi_update_infoframes(connector, state);
+	
+	if (!hdmi->dclk_en) {
+		mutex_lock(&hdmi->audio_mutex);
+		if (hdmi->plat_data->dclk_set)
+			hdmi->plat_data->dclk_set(data, true);
+		hdmi->dclk_en = true;
+		mutex_unlock(&hdmi->audio_mutex);
+	}
+
+	//extcon_set_state_sync(hdmi->extcon, EXTCON_DISP_HDMI, true);
+	//handle_plugged_change(hdmi, true);
 }
 
 static void dw_hdmi_qp_bridge_atomic_disable(struct drm_bridge *bridge,
 					     struct drm_bridge_state *old_state)
 {
 	struct dw_hdmi_qp *hdmi = bridge->driver_private;
+	void *data = hdmi->plat_data->phy_data;
+
+	//extcon_set_state_sync(hdmi->extcon, EXTCON_DISP_HDMI, false);
+	//handle_plugged_change(hdmi, false);
+	mutex_lock(&hdmi->mutex);
+
+	if (hdmi->dclk_en) {
+		mutex_lock(&hdmi->audio_mutex);
+		if (hdmi->plat_data->dclk_set)
+			hdmi->plat_data->dclk_set(data, false);
+		hdmi->dclk_en = false;
+		mutex_unlock(&hdmi->audio_mutex);
+	};
 
 	hdmi->curr_conn = NULL;
 	hdmi->phy.ops->disable(hdmi, hdmi->phy.data);
@@ -1249,7 +1308,6 @@ struct dw_hdmi_qp *dw_hdmi_qp_bind(struct platform_device *pdev,
 	hdmi->sample_rate = 48000;
 
 	mutex_init(&hdmi->audio_mutex);
-	spin_lock_init(&hdmi->audio_lock);
 
 	regs = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(regs))
diff --git a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
index fe33092ab..f98400ad4 100644
--- a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
+++ b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
@@ -348,6 +348,40 @@ dw_hdmi_rockchip_encoder_atomic_check(struct drm_encoder *encoder,
 	return 0;
 }
 
+static int dw_hdmi_dclk_set(void *data, bool enable)
+{
+	struct rockchip_hdmi *hdmi = (struct rockchip_hdmi *)data;
+	char clk_name[16];
+	struct clk *dclk;
+	int ret;
+
+	snprintf(clk_name, sizeof(clk_name), "dclk_vp%d", hdmi->vp_id);
+
+	dclk = devm_clk_get_optional(hdmi->dev, clk_name);
+	if (IS_ERR(dclk)) {
+		DRM_DEV_ERROR(hdmi->dev, "failed to get %s\n", clk_name);
+		return PTR_ERR(dclk);
+	} else if (!dclk) {
+		if (hdmi->is_hdmi_qp) {
+			DRM_DEV_ERROR(hdmi->dev, "failed to get %s\n", clk_name);
+			return -ENOENT;
+		}
+
+		return 0;
+	}
+
+	if (enable) {
+		ret = clk_prepare_enable(dclk);
+		if (ret < 0)
+			DRM_DEV_ERROR(hdmi->dev, "failed to enable dclk for video port%d - %d\n",
+				      hdmi->vp_id, ret);
+	} else {
+		clk_disable_unprepare(dclk);
+	}
+
+	return 0;
+}
+
 static const struct drm_encoder_helper_funcs dw_hdmi_rockchip_encoder_helper_funcs = {
 	.mode_fixup = dw_hdmi_rockchip_encoder_mode_fixup,
 	.mode_set   = dw_hdmi_rockchip_encoder_mode_set,
@@ -575,6 +609,7 @@ static int dw_hdmi_rockchip_bind(struct device *dev, struct device *master,
 	plat_data->phy_data = hdmi;
 	plat_data->priv_data = hdmi;
 	encoder = &hdmi->encoder.encoder;
+	plat_data->dclk_set = dw_hdmi_dclk_set;
 
 	encoder->possible_crtcs = drm_of_find_possible_crtcs(drm, dev->of_node);
 	rockchip_drm_encoder_set_crtc_endpoint_id(&hdmi->encoder,
diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index fa9239b57..b593965d1 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -165,6 +165,7 @@ struct dw_hdmi_plat_data {
 
 	unsigned int disable_cec : 1;
 	unsigned int alt_yuv_map : 1;
+	int (*dclk_set)(void *data, bool enable);
 };
 
 struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
@@ -224,6 +225,7 @@ void dw_hdmi_qp_set_sample_rate(struct dw_hdmi_qp *hdmi, unsigned int rate);
 void dw_hdmi_qp_set_channel_count(struct dw_hdmi_qp *hdmi, unsigned int cnt);
 void dw_hdmi_qp_set_channel_status(struct dw_hdmi_qp *hdmi, u8 *channel_status);
 void dw_hdmi_qp_set_channel_allocation(struct dw_hdmi_qp *hdmi, unsigned int ca);
+void dw_hdmi_qp_set_audio_infoframe(struct dw_hdmi_qp *hdmi);
 void dw_hdmi_qp_audio_enable(struct dw_hdmi_qp *hdmi);
 void dw_hdmi_qp_audio_disable(struct dw_hdmi_qp *hdmi);
 
-- 
2.46.0

