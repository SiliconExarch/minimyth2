From 06578817a2bd32d7c3c8cf686ad21792eb3f53ff Mon Sep 17 00:00:00 2001
From: Detlev Casanova <detlev.casanova@collabora.com>
Date: Thu, 3 Oct 2024 17:16:09 -0400
Subject: [PATCH 94/94] wip: Fix HDMI Audio

---
 .../bridge/synopsys/dw-hdmi-qp-i2s-audio.c    |   6 +-
 drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c  | 143 ++++++++++--------
 drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c   |   4 +-
 include/drm/bridge/dw_hdmi.h                  |  27 +---
 include/drm/bridge/dw_hdmi_qp.h               |  39 +++++
 5 files changed, 124 insertions(+), 95 deletions(-)

diff --git a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-i2s-audio.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-i2s-audio.c
index e07c2b423..84a3f71a7 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-i2s-audio.c
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp-i2s-audio.c
@@ -9,7 +9,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/module.h>
 
-#include <drm/bridge/dw_hdmi.h>
+#include <drm/bridge/dw_hdmi_qp.h>
 #include <drm/drm_crtc.h>
 
 #include <sound/hdmi-codec.h>
@@ -164,13 +164,11 @@ static int snd_dw_hdmi_qp_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int snd_dw_hdmi_qp_remove(struct platform_device *pdev)
+static void snd_dw_hdmi_qp_remove(struct platform_device *pdev)
 {
 	struct platform_device *platform = dev_get_drvdata(&pdev->dev);
 
 	platform_device_unregister(platform);
-
-	return 0;
 }
 
 static struct platform_driver snd_dw_hdmi_qp_driver = {
diff --git a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c
index fcc785e2f..c7eba9689 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c
@@ -134,6 +134,7 @@ struct dw_hdmi_qp_i2c {
 
 struct dw_hdmi_qp {
 	struct drm_bridge bridge;
+	struct platform_device *audio;
 
 	struct device *dev;
 	struct dw_hdmi_qp_i2c *i2c;
@@ -150,6 +151,17 @@ struct dw_hdmi_qp {
 	struct drm_connector *curr_conn;
 	unsigned long long pix_clock;
 
+	// from dw_hdmi
+	spinlock_t audio_lock;
+	//struct mutex audio_mutex;
+	unsigned int sample_non_pcm;
+	unsigned int sample_width;
+	//unsigned int sample_rate;
+	unsigned int channels;
+	//unsigned int audio_cts;
+	//unsigned int audio_n;
+	//bool audio_enable;
+
 	struct mutex audio_mutex;
 	unsigned int sample_rate;
 	unsigned int audio_cts;
@@ -157,14 +169,37 @@ struct dw_hdmi_qp {
 	bool audio_enable;
 	void (*enable_audio)(struct dw_hdmi_qp *hdmi);
 	void (*disable_audio)(struct dw_hdmi_qp *hdmi);
+	bool dclk_en;
 
 	struct regmap *regm;
 };
 
+static void dw_hdmi_qp_write(struct dw_hdmi_qp *hdmi, unsigned int val,
+			     int offset)
+{
+	regmap_write(hdmi->regm, offset, val);
+}
+
+static unsigned int dw_hdmi_qp_read(struct dw_hdmi_qp *hdmi, int offset)
+{
+	unsigned int val = 0;
+
+	regmap_read(hdmi->regm, offset, &val);
+
+	return val;
+}
+
+static void dw_hdmi_qp_mod(struct dw_hdmi_qp *hdmi, unsigned int data,
+			   unsigned int mask, unsigned int reg)
+{
+	regmap_update_bits(hdmi->regm, reg, mask, data);
+}
+
+// FIXME: IS THIS NEEDED for audio ?
 int dw_hdmi_qp_set_plugged_cb(struct dw_hdmi_qp *hdmi, hdmi_codec_plugged_cb fn,
 			      struct device *codec_dev)
 {
-	bool plugged;
+	/*bool plugged;
 
 	mutex_lock(&hdmi->mutex);
 	hdmi->plugged_cb = fn;
@@ -172,7 +207,7 @@ int dw_hdmi_qp_set_plugged_cb(struct dw_hdmi_qp *hdmi, hdmi_codec_plugged_cb fn,
 	plugged = hdmi->last_connector_result == connector_status_connected;
 	handle_plugged_change(hdmi, plugged);
 	mutex_unlock(&hdmi->mutex);
-
+*/
 	return 0;
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_plugged_cb);
@@ -181,17 +216,17 @@ static void hdmi_set_cts_n(struct dw_hdmi_qp *hdmi, unsigned int cts,
 			   unsigned int n)
 {
 	/* Set N */
-	hdmi_modb(hdmi, n, AUDPKT_ACR_N_VALUE, AUDPKT_ACR_CONTROL0);
+	dw_hdmi_qp_mod(hdmi, n, AUDPKT_ACR_N_VALUE, AUDPKT_ACR_CONTROL0);
 
 	/* Set CTS */
 	if (cts)
-		hdmi_modb(hdmi, AUDPKT_ACR_CTS_OVR_EN, AUDPKT_ACR_CTS_OVR_EN_MSK,
+		dw_hdmi_qp_mod(hdmi, AUDPKT_ACR_CTS_OVR_EN, AUDPKT_ACR_CTS_OVR_EN_MSK,
 			  AUDPKT_ACR_CONTROL1);
 	else
-		hdmi_modb(hdmi, 0, AUDPKT_ACR_CTS_OVR_EN_MSK,
+		dw_hdmi_qp_mod(hdmi, 0, AUDPKT_ACR_CTS_OVR_EN_MSK,
 			  AUDPKT_ACR_CONTROL1);
 
-	hdmi_modb(hdmi, AUDPKT_ACR_CTS_OVR_VAL(cts), AUDPKT_ACR_CTS_OVR_VAL_MSK,
+	dw_hdmi_qp_mod(hdmi, AUDPKT_ACR_CTS_OVR_VAL(cts), AUDPKT_ACR_CTS_OVR_VAL_MSK,
 		  AUDPKT_ACR_CONTROL1);
 }
 
@@ -329,14 +364,14 @@ static unsigned int hdmi_find_n(struct dw_hdmi_qp *hdmi, unsigned long pixel_clk
 				unsigned long sample_rate)
 {
 	struct dw_hdmi_link_config *link_cfg = NULL;
-	void *data = hdmi->plat_data->phy_data;
+	//void *data = hdmi->plat_data->phy_data;
 	int n;
 
-	if (hdmi->plat_data->get_link_cfg) {
+	/*if (hdmi->plat_data->get_link_cfg) {
 		link_cfg = hdmi->plat_data->get_link_cfg(data);
 		if (link_cfg && link_cfg->frl_mode)
 			return hdmi_match_frl_n_table(hdmi, link_cfg->rate_per_lane, sample_rate);
-	}
+	}*/
 
 	n = hdmi_match_tmds_n_table(hdmi, pixel_clk, sample_rate);
 	if (n > 0)
@@ -354,25 +389,26 @@ void dw_hdmi_qp_set_audio_interface(struct dw_hdmi_qp *hdmi,
 {
 	u32 conf0 = 0;
 
+	// FIXME: dclk_en seems needed to activate audio...
 	mutex_lock(&hdmi->audio_mutex);
-	if (!hdmi->dclk_en) {
+	/*if (!hdmi->dclk_en) {
 		mutex_unlock(&hdmi->audio_mutex);
 		return;
-	}
+	}*/
 
 	/* Reset the audio data path of the AVP */
-	hdmi_writel(hdmi, AVP_DATAPATH_PACKET_AUDIO_SWINIT_P, GLOBAL_SWRESET_REQUEST);
+	dw_hdmi_qp_write(hdmi, AVP_DATAPATH_PACKET_AUDIO_SWINIT_P, GLOBAL_SWRESET_REQUEST);
 
 	/* Disable AUDS, ACR, AUDI */
-	hdmi_modb(hdmi, 0,
+	dw_hdmi_qp_mod(hdmi, 0,
 		  PKTSCHED_ACR_TX_EN | PKTSCHED_AUDS_TX_EN | PKTSCHED_AUDI_TX_EN,
 		  PKTSCHED_PKT_EN);
 
 	/* Clear the audio FIFO */
-	hdmi_writel(hdmi, AUDIO_FIFO_CLR_P, AUDIO_INTERFACE_CONTROL0);
+	dw_hdmi_qp_write(hdmi, AUDIO_FIFO_CLR_P, AUDIO_INTERFACE_CONTROL0);
 
 	/* Select I2S interface as the audio source */
-	hdmi_modb(hdmi, AUD_IF_I2S, AUD_IF_SEL_MSK, AUDIO_INTERFACE_CONFIG0);
+	dw_hdmi_qp_mod(hdmi, AUD_IF_I2S, AUD_IF_SEL_MSK, AUDIO_INTERFACE_CONFIG0);
 
 	/* Enable the active i2s lanes */
 	switch (hparms->channels) {
@@ -390,7 +426,7 @@ void dw_hdmi_qp_set_audio_interface(struct dw_hdmi_qp *hdmi,
 		break;
 	}
 
-	hdmi_modb(hdmi, conf0, I2S_LINES_EN_MSK, AUDIO_INTERFACE_CONFIG0);
+	dw_hdmi_qp_mod(hdmi, conf0, I2S_LINES_EN_MSK, AUDIO_INTERFACE_CONFIG0);
 
 	/*
 	 * Enable bpcuv generated internally for L-PCM, or received
@@ -406,11 +442,11 @@ void dw_hdmi_qp_set_audio_interface(struct dw_hdmi_qp *hdmi,
 		break;
 	}
 
-	hdmi_modb(hdmi, conf0, I2S_BPCUV_RCV_MSK | AUD_FORMAT_MSK,
+	dw_hdmi_qp_mod(hdmi, conf0, I2S_BPCUV_RCV_MSK | AUD_FORMAT_MSK,
 		  AUDIO_INTERFACE_CONFIG0);
 
 	/* Enable audio FIFO auto clear when overflow */
-	hdmi_modb(hdmi, AUD_FIFO_INIT_ON_OVF_EN, AUD_FIFO_INIT_ON_OVF_MSK,
+	dw_hdmi_qp_mod(hdmi, AUD_FIFO_INIT_ON_OVF_EN, AUD_FIFO_INIT_ON_OVF_MSK,
 		  AUDIO_INTERFACE_CONFIG0);
 
 	mutex_unlock(&hdmi->audio_mutex);
@@ -456,23 +492,23 @@ void dw_hdmi_qp_set_channel_status(struct dw_hdmi_qp *hdmi,
 	if (ref2stream)
 		channel_status[0] |= IEC958_AES0_NONAUDIO;
 
-	if ((hdmi_readl(hdmi, AUDIO_INTERFACE_CONFIG0) & GENMASK(25, 24)) == AUD_HBR) {
+	if ((dw_hdmi_qp_read(hdmi, AUDIO_INTERFACE_CONFIG0) & GENMASK(25, 24)) == AUD_HBR) {
 		/* fixup cs for HBR */
 		channel_status[3] = (channel_status[3] & 0xf0) | IEC958_AES3_CON_FS_768000;
 		channel_status[4] = (channel_status[4] & 0x0f) | IEC958_AES4_CON_ORIGFS_NOTID;
 	}
 
-	hdmi_writel(hdmi, channel_status[0] | (channel_status[1] << 8),
+	dw_hdmi_qp_write(hdmi, channel_status[0] | (channel_status[1] << 8),
 		    AUDPKT_CHSTATUS_OVR0);
 
 	regmap_bulk_write(hdmi->regm, AUDPKT_CHSTATUS_OVR1, &channel_status[3], 1);
 
 	if (ref2stream)
-		hdmi_modb(hdmi, 0,
+		dw_hdmi_qp_mod(hdmi, 0,
 			  AUDPKT_PBIT_FORCE_EN_MASK | AUDPKT_CHSTATUS_OVR_EN_MASK,
 			  AUDPKT_CONTROL0);
 	else
-		hdmi_modb(hdmi, AUDPKT_PBIT_FORCE_EN | AUDPKT_CHSTATUS_OVR_EN,
+		dw_hdmi_qp_mod(hdmi, AUDPKT_PBIT_FORCE_EN | AUDPKT_CHSTATUS_OVR_EN,
 			  AUDPKT_PBIT_FORCE_EN_MASK | AUDPKT_CHSTATUS_OVR_EN_MASK,
 			  AUDPKT_CONTROL0);
 
@@ -503,20 +539,20 @@ static void hdmi_init_clk_regenerator(struct dw_hdmi_qp *hdmi)
 static void hdmi_clk_regenerator_update_pixel_clock(struct dw_hdmi_qp *hdmi)
 {
 	mutex_lock(&hdmi->audio_mutex);
-	if (hdmi->dclk_en)
+	/*if (hdmi->dclk_en)
 		hdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,
-					 hdmi->sample_rate);
+					 hdmi->sample_rate);*/
 	mutex_unlock(&hdmi->audio_mutex);
 }
 
 void dw_hdmi_qp_set_sample_rate(struct dw_hdmi_qp *hdmi, unsigned int rate)
 {
 	mutex_lock(&hdmi->audio_mutex);
-	if (hdmi->dclk_en) {
+	/*if (hdmi->dclk_en) {
 		hdmi->sample_rate = rate;
 		hdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,
 					 hdmi->sample_rate);
-	}
+	}*/
 	mutex_unlock(&hdmi->audio_mutex);
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_sample_rate);
@@ -553,7 +589,7 @@ static int dw_hdmi_qp_init_audio_infoframe(struct dw_hdmi_qp *hdmi)
 	}
 
 	regmap_bulk_write(hdmi->regm, PKT_AUDI_CONTENTS1, &infoframe_buf[3], 2);
-	hdmi_modb(hdmi,
+	dw_hdmi_qp_mod(hdmi,
 		  PKTSCHED_ACR_TX_EN | PKTSCHED_AUDI_TX_EN,
 		  PKTSCHED_ACR_TX_EN | PKTSCHED_AUDI_TX_EN,
 		  PKTSCHED_PKT_EN);
@@ -601,13 +637,13 @@ void dw_hdmi_qp_set_audio_infoframe(struct dw_hdmi_qp *hdmi,
 	regmap_bulk_write(hdmi->regm, PKT_AUDI_CONTENTS1, &infoframe_buf[3], 2);
 
 	/* Enable ACR, AUDI, AMD */
-	hdmi_modb(hdmi,
+	dw_hdmi_qp_mod(hdmi,
 		  PKTSCHED_ACR_TX_EN | PKTSCHED_AUDI_TX_EN | PKTSCHED_AMD_TX_EN,
 		  PKTSCHED_ACR_TX_EN | PKTSCHED_AUDI_TX_EN | PKTSCHED_AMD_TX_EN,
 		  PKTSCHED_PKT_EN);
 
 	/* Enable AUDS */
-	hdmi_modb(hdmi, PKTSCHED_AUDS_TX_EN, PKTSCHED_AUDS_TX_EN, PKTSCHED_PKT_EN);
+	dw_hdmi_qp_mod(hdmi, PKTSCHED_AUDS_TX_EN, PKTSCHED_AUDS_TX_EN, PKTSCHED_PKT_EN);
 	mutex_unlock(&hdmi->audio_mutex);
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_audio_infoframe);
@@ -615,10 +651,10 @@ EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_audio_infoframe);
 static void hdmi_enable_audio_clk(struct dw_hdmi_qp *hdmi, bool enable)
 {
 	if (enable)
-		hdmi_modb(hdmi, 0,
+		dw_hdmi_qp_mod(hdmi, 0,
 			  AVP_DATAPATH_PACKET_AUDIO_SWDISABLE, GLOBAL_SWDISABLE);
 	else
-		hdmi_modb(hdmi, AVP_DATAPATH_PACKET_AUDIO_SWDISABLE,
+		dw_hdmi_qp_mod(hdmi, AVP_DATAPATH_PACKET_AUDIO_SWDISABLE,
 			  AVP_DATAPATH_PACKET_AUDIO_SWDISABLE, GLOBAL_SWDISABLE);
 }
 
@@ -637,9 +673,9 @@ static void dw_hdmi_i2s_audio_disable(struct dw_hdmi_qp *hdmi)
 	 * This also fix POP sound on some SINK devices which wakeup
 	 * from suspend to active.
 	 */
-	hdmi_modb(hdmi, I2S_BPCUV_RCV_DIS, I2S_BPCUV_RCV_MSK,
+	dw_hdmi_qp_mod(hdmi, I2S_BPCUV_RCV_DIS, I2S_BPCUV_RCV_MSK,
 		  AUDIO_INTERFACE_CONFIG0);
-	hdmi_modb(hdmi, AUDPKT_PBIT_FORCE_EN | AUDPKT_CHSTATUS_OVR_EN,
+	dw_hdmi_qp_mod(hdmi, AUDPKT_PBIT_FORCE_EN | AUDPKT_CHSTATUS_OVR_EN,
 		  AUDPKT_PBIT_FORCE_EN_MASK | AUDPKT_CHSTATUS_OVR_EN_MASK,
 		  AUDPKT_CONTROL0);
 }
@@ -719,27 +755,6 @@ void dw_hdmi_qp_set_high_tmds_clock_ratio(struct dw_hdmi_qp *hdmi,
 }
 EXPORT_SYMBOL_GPL(dw_hdmi_qp_set_high_tmds_clock_ratio);
 
-static void dw_hdmi_qp_write(struct dw_hdmi_qp *hdmi, unsigned int val,
-			     int offset)
-{
-	regmap_write(hdmi->regm, offset, val);
-}
-
-static unsigned int dw_hdmi_qp_read(struct dw_hdmi_qp *hdmi, int offset)
-{
-	unsigned int val = 0;
-
-	regmap_read(hdmi->regm, offset, &val);
-
-	return val;
-}
-
-static void dw_hdmi_qp_mod(struct dw_hdmi_qp *hdmi, unsigned int data,
-			   unsigned int mask, unsigned int reg)
-{
-	regmap_update_bits(hdmi->regm, reg, mask, data);
-}
-
 static int dw_hdmi_qp_i2c_read(struct dw_hdmi_qp *hdmi,
 			       unsigned char *buf, unsigned int length)
 {
@@ -1281,6 +1296,7 @@ static void dw_hdmi_qp_setup(struct dw_hdmi_qp *hdmi,
 	}
 
 	/* HDMI Initialization Step E - Configure audio */
+	((struct dw_hdmi_qp_i2s_audio_data*)hdmi->audio->dev.platform_data)->eld = connector->eld;
 	hdmi_clk_regenerator_update_pixel_clock(hdmi);
 	hdmi_enable_audio_clk(hdmi, hdmi->audio_enable);
 
@@ -1352,13 +1368,13 @@ static void dw_hdmi_qp_bridge_atomic_enable(struct drm_bridge *bridge,
 
 	drm_atomic_helper_connector_hdmi_update_infoframes(connector, state);
 	
-	if (!hdmi->dclk_en) {
+	/*if (!hdmi->dclk_en) {
 		mutex_lock(&hdmi->audio_mutex);
 		if (hdmi->plat_data->dclk_set)
 			hdmi->plat_data->dclk_set(data, true);
 		hdmi->dclk_en = true;
 		mutex_unlock(&hdmi->audio_mutex);
-	}
+	}*/
 	dw_hdmi_qp_init_audio_infoframe(hdmi);
 	dw_hdmi_qp_audio_enable(hdmi);
 	hdmi_clk_regenerator_update_pixel_clock(hdmi);
@@ -1371,19 +1387,19 @@ static void dw_hdmi_qp_bridge_atomic_disable(struct drm_bridge *bridge,
 					     struct drm_bridge_state *old_state)
 {
 	struct dw_hdmi_qp *hdmi = bridge->driver_private;
-	void *data = hdmi->plat_data->phy_data;
+	//void *data = hdmi->plat_data->phy_data;
 
 	//extcon_set_state_sync(hdmi->extcon, EXTCON_DISP_HDMI, false);
 	//handle_plugged_change(hdmi, false);
-	mutex_lock(&hdmi->mutex);
+	//mutex_lock(&hdmi->mutex);
 
-	if (hdmi->dclk_en) {
+	/*if (hdmi->dclk_en) {
 		mutex_lock(&hdmi->audio_mutex);
 		if (hdmi->plat_data->dclk_set)
 			hdmi->plat_data->dclk_set(data, false);
 		hdmi->dclk_en = false;
 		mutex_unlock(&hdmi->audio_mutex);
-	};
+	};*/
 
 	hdmi->curr_conn = NULL;
 	hdmi->phy.ops->disable(hdmi, hdmi->phy.data);
@@ -1616,10 +1632,9 @@ struct dw_hdmi_qp *dw_hdmi_qp_bind(struct platform_device *pdev,
 		hdmi->bridge.ddc = NULL;
 
 	audio.hdmi      = hdmi;
-	audio.eld       = hdmi->connector.eld;
-	audio.write     = hdmi_writel;
-	audio.read      = hdmi_readl;
-	audio.mod       = hdmi_modb;
+	audio.write     = dw_hdmi_qp_write;
+	audio.read      = dw_hdmi_qp_read;
+	audio.mod       = dw_hdmi_qp_mod;
 	hdmi->enable_audio = dw_hdmi_i2s_audio_enable;
 	hdmi->disable_audio = dw_hdmi_i2s_audio_disable;
 
diff --git a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
index f98400ad4..d19a1ab51 100644
--- a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
+++ b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
@@ -348,6 +348,7 @@ dw_hdmi_rockchip_encoder_atomic_check(struct drm_encoder *encoder,
 	return 0;
 }
 
+/*
 static int dw_hdmi_dclk_set(void *data, bool enable)
 {
 	struct rockchip_hdmi *hdmi = (struct rockchip_hdmi *)data;
@@ -381,6 +382,7 @@ static int dw_hdmi_dclk_set(void *data, bool enable)
 
 	return 0;
 }
+*/
 
 static const struct drm_encoder_helper_funcs dw_hdmi_rockchip_encoder_helper_funcs = {
 	.mode_fixup = dw_hdmi_rockchip_encoder_mode_fixup,
@@ -609,7 +611,7 @@ static int dw_hdmi_rockchip_bind(struct device *dev, struct device *master,
 	plat_data->phy_data = hdmi;
 	plat_data->priv_data = hdmi;
 	encoder = &hdmi->encoder.encoder;
-	plat_data->dclk_set = dw_hdmi_dclk_set;
+	//plat_data->dclk_set = dw_hdmi_dclk_set;
 
 	encoder->possible_crtcs = drm_of_find_possible_crtcs(drm, dev->of_node);
 	rockchip_drm_encoder_set_crtc_endpoint_id(&hdmi->encoder,
diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index c66054087..287a59af0 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -13,6 +13,7 @@ struct drm_display_info;
 struct drm_display_mode;
 struct drm_encoder;
 struct dw_hdmi;
+struct dw_hdmi_qp;
 struct platform_device;
 
 /**
@@ -93,13 +94,6 @@ enum dw_hdmi_phy_type {
 	DW_HDMI_PHY_VENDOR_PHY = 0xfe,
 };
 
-struct dw_hdmi_audio_frl_n {
-	unsigned int r_bit;
-	unsigned int n_32k;
-	unsigned int n_44k1;
-	unsigned int n_48k;
-};
-
 struct dw_hdmi_mpll_config {
 	unsigned long mpixelclock;
 	struct {
@@ -225,23 +219,4 @@ void dw_hdmi_qp_resume(struct device *dev, struct dw_hdmi *hdmi);
 
 bool dw_hdmi_bus_fmt_is_420(struct dw_hdmi *hdmi);
 
-void dw_hdmi_qp_cec_set_hpd(struct dw_hdmi_qp *hdmi, bool plug_in, bool change);
-void dw_hdmi_qp_set_cec_adap(struct dw_hdmi_qp *hdmi, struct cec_adapter *adap);
-int dw_hdmi_qp_set_earc(struct dw_hdmi_qp *hdmi);
-void dw_hdmi_qp_set_sample_rate(struct dw_hdmi_qp *hdmi, unsigned int rate);
-void dw_hdmi_qp_set_channel_count(struct dw_hdmi_qp *hdmi, unsigned int cnt);
-void dw_hdmi_qp_set_channel_status(struct dw_hdmi_qp *hdmi, u8 *channel_status,
-				   bool ref2stream);
-void dw_hdmi_qp_set_channel_allocation(struct dw_hdmi_qp *hdmi, unsigned int ca);
-void dw_hdmi_qp_set_audio_interface(struct dw_hdmi_qp *hdmi,
-				    struct hdmi_codec_daifmt *fmt,
-				    struct hdmi_codec_params *hparms);
-void dw_hdmi_qp_set_audio_infoframe(struct dw_hdmi_qp *hdmi,
-				    struct hdmi_codec_params *hparms);
-void dw_hdmi_qp_audio_enable(struct dw_hdmi_qp *hdmi);
-void dw_hdmi_qp_audio_disable(struct dw_hdmi_qp *hdmi);
-bool dw_hdmi_qp_connected(struct dw_hdmi_qp *hdmi);
-int dw_hdmi_qp_set_plugged_cb(struct dw_hdmi_qp *hdmi, hdmi_codec_plugged_cb fn,
-			      struct device *codec_dev);
-
 #endif /* __IMX_HDMI_H__ */
diff --git a/include/drm/bridge/dw_hdmi_qp.h b/include/drm/bridge/dw_hdmi_qp.h
index 0b9c7a88a..1c7e6001b 100644
--- a/include/drm/bridge/dw_hdmi_qp.h
+++ b/include/drm/bridge/dw_hdmi_qp.h
@@ -7,12 +7,17 @@
 #ifndef __DW_HDMI_QP__
 #define __DW_HDMI_QP__
 
+#include <sound/hdmi-codec.h>
+
 struct device;
 struct drm_display_info;
 struct drm_encoder;
 struct dw_hdmi_qp;
 struct platform_device;
 
+//struct hdmi_codec_params;
+//struct hdmi_codec_daifmt;
+
 struct dw_hdmi_qp_phy_ops {
 	int (*init)(struct dw_hdmi_qp *hdmi, void *data,
 		    const struct drm_display_info *display);
@@ -26,6 +31,20 @@ struct dw_hdmi_qp_plat_data {
 	void *phy_data;
 };
 
+struct dw_hdmi_audio_frl_n {
+	unsigned int r_bit;
+	unsigned int n_32k;
+	unsigned int n_44k1;
+	unsigned int n_48k;
+};
+
+struct dw_hdmi_audio_tmds_n {
+	unsigned long tmds;
+	unsigned int n_32k;
+	unsigned int n_44k1;
+	unsigned int n_48k;
+};
+
 void dw_hdmi_qp_set_high_tmds_clock_ratio(struct dw_hdmi_qp *hdmi,
 					  const struct drm_display_info *display);
 
@@ -34,4 +53,24 @@ struct dw_hdmi_qp *dw_hdmi_qp_bind(struct platform_device *pdev,
 				   struct drm_encoder *encoder,
 				   const struct dw_hdmi_qp_plat_data *plat_data);
 void dw_hdmi_qp_resume(struct device *dev, struct dw_hdmi_qp *hdmi);
+
+
+//void dw_hdmi_qp_cec_set_hpd(struct dw_hdmi_qp *hdmi, bool plug_in, bool change);
+//void dw_hdmi_qp_set_cec_adap(struct dw_hdmi_qp *hdmi, struct cec_adapter *adap);
+//int dw_hdmi_qp_set_earc(struct dw_hdmi_qp *hdmi);
+void dw_hdmi_qp_set_sample_rate(struct dw_hdmi_qp *hdmi, unsigned int rate);
+void dw_hdmi_qp_set_channel_count(struct dw_hdmi_qp *hdmi, unsigned int cnt);
+void dw_hdmi_qp_set_channel_status(struct dw_hdmi_qp *hdmi, u8 *channel_status,
+				   bool ref2stream);
+void dw_hdmi_qp_set_channel_allocation(struct dw_hdmi_qp *hdmi, unsigned int ca);
+void dw_hdmi_qp_set_audio_interface(struct dw_hdmi_qp *hdmi,
+				    struct hdmi_codec_daifmt *fmt,
+				    struct hdmi_codec_params *hparms);
+void dw_hdmi_qp_set_audio_infoframe(struct dw_hdmi_qp *hdmi,
+				    struct hdmi_codec_params *hparms);
+void dw_hdmi_qp_audio_enable(struct dw_hdmi_qp *hdmi);
+void dw_hdmi_qp_audio_disable(struct dw_hdmi_qp *hdmi);
+bool dw_hdmi_qp_connected(struct dw_hdmi_qp *hdmi);
+int dw_hdmi_qp_set_plugged_cb(struct dw_hdmi_qp *hdmi, hdmi_codec_plugged_cb fn,
+			      struct device *codec_dev);
 #endif /* __DW_HDMI_QP__ */
-- 
2.46.0

